<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>SSE</title><link rel="stylesheet" type="text/css" href="../../docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"/><meta name="keywords" content="Spring, Spring Boot, Spring Cloud, Spring Eureka, Spring Config"/><link rel="prev" href="ch42s08.xhtml" title="Flux 返回多条数据"/><link rel="next" href="ch42s10.xhtml" title="并发"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">SSE</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch42s08.xhtml">上一页</a> </td><th style="width: 60%; text-align: center; ">第 42 章 WebFlux framework</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch42s10.xhtml">下一页</a></td></tr></table><hr/></div></header><section class="section" id="webflux.sse"><div class="titlepage"><div><div><h2 class="title" style="clear: both">SSE</h2></div></div></div><section class="section" id="id1049"><div class="titlepage"><div><div><h3 class="title">一次性事件</h3></div></div></div><pre class="programlisting">
			
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux&lt;String&gt; createConnectionAndSendEvents() {
        return Flux.just("Alpha", "Omega");
    }			
			
		</pre><p>curl 访问 SSE 需要设置HTTP头 -H "Accept: text/event-stream" </p><pre class="screen">
			
neo@MacBook-Pro-M2 ~ % curl -H "Accept: text/event-stream" -X 'GET' 'http://localhost:8080/mock/sse'
data:Alpha

data:Omega			
			
		</pre><div class="tip"><h3 class="title">提示</h3>Safari 浏览器不支持 SSE推送，微软的 Egde 支持。</div></section><section class="section" id="id1050"><div class="titlepage"><div><div><h3 class="title">周期性事件</h3></div></div></div><p>每间隔一秒发送一次数据</p><pre class="programlisting">
			
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux&lt;String&gt; getWords() {
        String[] WORDS = "The quick brown fox jumps over the lazy dog.".split(" ");
        return Flux
                .zip(Flux.just(WORDS), Flux.interval(Duration.ofSeconds(1)))
                .map(Tuple2::getT1);
    }
    
	@GetMapping("/random")
	public Flux&lt;ServerSentEvent&lt;Integer&gt;&gt; randomNumbers() {
		return Flux.interval(Duration.ofSeconds(1)).map(seq -&gt; Tuples.of(seq, ThreadLocalRandom.current().nextInt())).map(data -&gt; ServerSentEvent.&lt;Integer&gt;builder().event("random").id(Long.toString(data.getT1())).data(data.getT2()).build());
	}    
	
	@GetMapping(path = "/stream-flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux&lt;String&gt; streamFlux() {
	    return Flux.interval(Duration.ofSeconds(1))
	      .map(sequence -&gt; "Flux - " + LocalTime.now().toString());
	}	
			
		</pre></section><section class="section" id="id1051"><div class="titlepage"><div><div><h3 class="title">SSE 完整的例子</h3></div></div></div><pre class="programlisting">
		
package cn.netkiller.webflux.controller;

import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerSentEvent;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;
import reactor.util.function.Tuples;

@RestController
@RequestMapping("/sse")
public class SseController {
	private int count_down = 10;

	public SseController() {

	}

	@GetMapping(value = "/launch", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux&lt;ServerSentEvent&lt;Object&gt;&gt; countDown() {

		return Flux.interval(Duration.ofSeconds(1)).map(seq -&gt; Tuples.of(seq, getCountDownSec())).map(data -&gt; ServerSentEvent.&lt;Object&gt;builder().event("launch").id(Long.toString(data.getT1())).data(data.getT2().toString()).build());
	}

	private String getCountDownSec() {
		if (count_down &gt; 0) {
			count_down--;
			return "倒计时：" + count_down;
		}
		return "发射";
	}



	@GetMapping("/range")
	public Flux&lt;Object&gt; range() {
		return Flux.range(10, 1).map(seq -&gt; Tuples.of(seq, getCountDownSec())).map(data -&gt; ServerSentEvent.&lt;Object&gt;builder().event("launch").id(Long.toString(data.getT1())).data(data.getT2().toString()).build());
	}
	
	// WebFlux 服务器推送(SSE - &gt;Server Send Event)
	@GetMapping(value = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	private Flux&lt;String&gt; flux() {
		Flux&lt;String&gt; result = Flux.fromStream(IntStream.range(1, 10).mapToObj(i -&gt; {
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
			}
			logger.info("sse " + i);
			return "flux data -- " + i;
		}));
		return result;
	}
}
		
		
		</pre><p>运行结果</p><pre class="screen">
		
id:0
event:launch
data:倒计时：9

id:1
event:launch
data:倒计时：8

id:2
event:launch
data:倒计时：7

id:3
event:launch
data:倒计时：6

id:4
event:launch
data:倒计时：5

id:5
event:launch
data:倒计时：4

id:6
event:launch
data:倒计时：3

id:7
event:launch
data:倒计时：2

id:8
event:launch
data:倒计时：1

id:9
event:launch
data:倒计时：0

id:10
event:launch
data:发射
		
		
		</pre></section><section class="section" id="id1052"><div class="titlepage"><div><div><h3 class="title">SSE Client 订阅实例</h3></div></div></div><pre class="programlisting">
			
 	@GetMapping("/server")
    public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamEvents() {
        return Flux.interval(Duration.ofSeconds(1))
                .map(sequence -&gt; ServerSentEvent.&lt;String&gt;builder()
                        .id(String.valueOf(sequence))
                        .event("test-event")
                        .data("LocalTime: " + LocalTime.now())
                        .build());
    }

    @GetMapping("/client")
    public void consumeServerSentEvent() {
        WebClient client = WebClient.create("http://localhost:8080");
        ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt; type
                = new ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt;() {
        };

        Flux&lt;ServerSentEvent&lt;String&gt;&gt; eventStream = client.get()
                .uri("mock/server")
                .retrieve()
                .bodyToFlux(type);

        eventStream.subscribe(
                content -&gt; log.info("Time: {} - event: name[{}], id [{}], content[{}] ",
                        LocalTime.now(), content.event(), content.id(), content.data()),
                error -&gt; log.error("Error receiving SSE: {}", error),
                () -&gt; log.info("Completed!!!"));
    }
			
		</pre></section></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch42s08.xhtml">上一页</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch42.xhtml">上一级</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch42s10.xhtml">下一页</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">Flux 返回多条数据 </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="../../index.xhtml">起始页</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> 并发</td></tr></table></div></footer></body></html>