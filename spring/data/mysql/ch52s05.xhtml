<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>JPQL @Query</title><link rel="stylesheet" type="text/css" href="../../docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"/><meta name="keywords" content="Spring, Spring Boot, Spring Cloud, Spring Eureka, Spring Config"/><link rel="prev" href="ch52s04.xhtml" title="TransactionTemplate"/><link rel="next" href="../redis/ch53.xhtml" title="第 53 章 Spring Data with Redis"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">JPQL @Query</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch52s04.xhtml">上一页</a> </td><th style="width: 60%; text-align: center; ">第 52 章 Spring Data with MySQL</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="../redis/ch53.xhtml">下一页</a></td></tr></table><hr/></div></header><section class="section" id="JPQL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">JPQL @Query</h2></div></div></div><section class="section" id="@Modifying"><div class="titlepage"><div><div><h3 class="title">@Modifying 更新/删除</h3></div></div></div><p>更新/删除操作需要加上 @Modifying 注解</p><pre class="programlisting">
			
@Modifying
@Query("update Money m set m.isDeleted=?2 where  m.money=?1")
void updateStateByMoney(Long money, Byte state);			
			
			</pre><pre class="programlisting">
			

  @Modifying(clearAutomatically=true, flushAutomatically = true)			
			
			</pre></section><section class="section" id="@Transactional"><div class="titlepage"><div><div><h3 class="title">事务 @Transactional</h3></div></div></div><div class="literallayout"><p><br/>
			<br/>
下面介绍一下@Transactional注解的参数以及使用：<br/>
<br/>
事物传播行为介绍:<br/>
<br/>
@Transactional(propagation=Propagation.REQUIRED) ：如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)<br/>
@Transactional(propagation=Propagation.NOT_SUPPORTED) ：容器不为这个方法开启事务<br/>
@Transactional(propagation=Propagation.REQUIRES_NEW) ：不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务<br/>
@Transactional(propagation=Propagation.MANDATORY) ：必须在一个已有的事务中执行,否则抛出异常<br/>
@Transactional(propagation=Propagation.NEVER) ：必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)<br/>
@Transactional(propagation=Propagation.SUPPORTS) ：如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.<br/>
事物超时设置:<br/>
<br/>
@Transactional(timeout=30) //默认是30秒<br/>
事务隔离级别:<br/>
<br/>
@Transactional(isolation = Isolation.READ_UNCOMMITTED)：读取未提交数据(会出现脏读, 不可重复读) 基本不使用<br/>
@Transactional(isolation = Isolation.READ_COMMITTED)：读取已提交数据(会出现不可重复读和幻读)<br/>
@Transactional(isolation = Isolation.REPEATABLE_READ)：可重复读(会出现幻读)<br/>
@Transactional(isolation = Isolation.SERIALIZABLE)：串行化 　MYSQL: 默认为REPEATABLE_READ级别 　SQLSERVER: 默认为READ_COMMITTED<br/>
@Transactional注解中常用参数说明<br/>
<br/>
注意的几点:<br/>
<br/>
@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.<br/>
用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException("注释");)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外(throw new Exception("注释");)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)<br/>
@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。<br/>
@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 元素的出现 开启 了事务行为。<br/>
Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。			<br/>
<br/>
			<br/>
			</p></div><section class="section" id="id1139"><div class="titlepage"><div><div><h4 class="title">删除更新需要 @Transactional 注解</h4></div></div></div><pre class="programlisting">
				
package cn.netkiller.api.repository;

import javax.transaction.Transactional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import cn.netkiller.api.domain.RecentRead;

@Repository
public interface RecentReadRepostitory extends CrudRepository&lt;RecentRead, Integer&gt; {

	Page&lt;RecentRead&gt; findByMemberIdOrderByIdDesc(int memberId, Pageable pageable);

	int countByMemberId(int memberId);
	
	@Transactional
	@Modifying
	@Query("DELETE FROM RecentRead r WHERE r.memberId = ?1 AND r.articleId = ?2")
	void deleteByMemberIdAndArticleId(int memberId, int articleId);
	
	@Transactional
	@Modifying
	@Query("delete from RecentRead where member_id = :member_id")
	public void deleteByMemberId(@Param("member_id") int memberId);

	int countByMemberIdAndArticleId(int memberId, int articleId);

}				
				
				</pre></section><section class="section" id="id1140"><div class="titlepage"><div><div><h4 class="title">回滚操作</h4></div></div></div><pre class="programlisting">
				
	// 指定Exception回滚
	@Transactional(rollbackFor=Exception.class)
    public void methodName() {
       // 不会回滚
       throw new Exception("...");
    }

	//指定Exception回滚，但其他异常不回滚
	@Transactional(noRollbackFor=Exception.class)
    public ItimDaoImpl getItemDaoImpl() {
        // 会回滚
        throw new RuntimeException("注释");
    }
				
				</pre><pre class="programlisting">
				
@Service
public class UserService {
    @Autowired
    private UserRepostitory userRepostitory;
    
    @Transactional
    public void add(User user) {
        try {
            userRepostitory.save(user);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
        // 不会回滚
    }
    @Transactional
    public void add(User user) throws Exception {
        try {
             userRepostitory.delete(user);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            // 抛出异常才会回滚
            throw new Exception(e);
        }
    }
}
				
				
				</pre></section><section class="section" id="id1141"><div class="titlepage"><div><div><h4 class="title">private、default、protected 和 final 不支持事物 </h4></div></div></div><p>@Transactional 必须与 public 一起使用，不能定义为 private、default、protected
				</p><pre class="programlisting">
				
@Service
public class UserService {
    @Transactional
    private void add(User user) {
         save(user);
    }
}
				
				</pre></section><section class="section" id="id1142"><div class="titlepage"><div><div><h4 class="title">Service 注意事项</h4></div></div></div><p>this 调用不支持事物</p><pre class="programlisting">
				
@Service
public class UserService {

    @Autowired
    private UserRepostitory userRepostitory;

    @Transactional
    public void add(User user) {
        userRepostitory.save(user);
        this.update(user);
    }

    @Transactional
    public void update(User user) {
        userRepostitory.update(user);
    }
}				
				
				</pre><p>解决方案</p><pre class="programlisting">
				
@Servcie
public class UserService {
   @Autowired
   prvate ProfileService profileService;

   public void save(User user) {
         profileService.save(user);
   }
}

 @Servcie
 public class ProfileService {

    @Transactional(rollbackFor=Exception.class)
    public void save(User user) {

    }

}				
				
				</pre></section><section class="section" id="id1143"><div class="titlepage"><div><div><h4 class="title">需要 @Service 注解配合使用</h4></div></div></div><p>@Transactional 需要在 @Controller、@Service、@Component、@Repository
					等注解下才能使用
				</p><pre class="programlisting">
				
// @Servcie
public class UserService {
	@Autowired
	prvate ProfileService profileService;
   
	@Transactional
	public void save(User user) {
         profileService.save(user);
	}
}				
				
				</pre><p>屏蔽 @Servcie 后观察 save 的 @Transactional 是不生效的。</p></section><section class="section" id="id1144"><div class="titlepage"><div><div><h4 class="title"/></div></div></div><pre class="programlisting">
				
@Service
public class UserService {

    @Autowired
    private UserRepostitory userRepostitory;
    @Autowired
    private RoleService roleService;

    @Transactional
    public void add(User user) throws Exception {
        userRepostitory.save(user);
        new Thread(() -&gt; {
            roleService.doOtherThing();
        }).start();
    }
}

@Service
public class RoleService {

    @Transactional
    public void doOtherThing() {
        ...
        ...
    }
}				
				
				</pre></section></section><section class="section" id="@Param"><div class="titlepage"><div><div><h3 class="title">参数传递</h3></div></div></div><pre class="programlisting">
				
package api.repository.oracle;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import api.domain.oracle.Member;

@Repository
public interface MemberRepository extends CrudRepository&lt;Member, Long&gt; {
	public Page&lt;Member&gt; findAll(Pageable pageable);

	// public Member findByBillno(String billno);

	public Member findById(String id);

	@Query("SELECT m FROM Member m WHERE m.status = 'Y' AND m.id = :id")
	public Member findFinishById(@Param("id") String id);

}
				
			</pre><pre class="programlisting">
				
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {
    @Query("SELECT p FROM Person p WHERE LOWER(p.lastName) = LOWER(:lastName)")
    public List&lt;Person&gt; find(@Param("lastName") String lastName);
}
				
			</pre></section><section class="section" id="Query.nativeQuery"><div class="titlepage"><div><div><h3 class="title">原生 SQL</h3></div></div></div><pre class="programlisting">
				
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

	@Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?0", nativeQuery = true)
	User findByEmailAddress(String emailAddress);
}
				
			</pre><p>insert ignore</p><pre class="programlisting">
				
	@Modifying
    @Query(value = "insert ignore into emp(create, modified, user_id, user_name, user_nickname, user_mail) values(?1, ?2, ?3, ?4, ?5, ?6)", nativeQuery = true)
    void insertIgnoreEmployee(Timestamp create, Timestamp modified, String userId, String name, String nickname, String mail);
				
				
			</pre></section><section class="section" id="id1145"><div class="titlepage"><div><div><h3 class="title">@Query 与 Pageagble</h3></div></div></div><p>
				<a class="ulink" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#_native_queries" target="_top">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#_native_queries</a>
			</p><pre class="programlisting">
			
@Query(value = "SELECT u FROM User u ORDER BY id")
Page&lt;User&gt; findAllUsersWithPagination(Pageable pageable);			
			
			</pre><pre class="programlisting">
				
package api.domain;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Index;
import javax.persistence.Table;

@Entity
@Table(indexes = { @Index(name = "address", columnList = "from_address,to_address"), @Index(name = "contractAddress", columnList = "contractAddress") })

public class TransactionHistory implements Serializable {
	private static final long serialVersionUID = 6710992220657056861L;
	@Id
	@Column(name = "blockNumber", unique = true, nullable = false, insertable = true, updatable = false)
	private int blockNumber;
	private String timeStamp;
	private String hash;
	@Column(name = "from_address")
	private String from;
	@Column(name = "to_address")
	private String to;
	private String value;
	private String gas;
	private String gasPrice;
	private String isError;
	private String contractAddress;
	private String gasUsed;
	private String symbol;

	public TransactionHistory() {
		// TODO Auto-generated constructor stub
	}

	public int getBlockNumber() {
		return blockNumber;
	}

	public void setBlockNumber(int blockNumber) {
		this.blockNumber = blockNumber;
	}

	public String getTimeStamp() {
		return timeStamp;
	}

	public void setTimeStamp(String timeStamp) {
		this.timeStamp = timeStamp;
	}

	public String getHash() {
		return hash;
	}

	public void setHash(String hash) {
		this.hash = hash;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}

	public String getTo() {
		return to;
	}

	public void setTo(String to) {
		this.to = to;
	}

	public String getValue() {
		return value;
	}

	public void setValue(String value) {
		this.value = value;
	}

	public String getGas() {
		return gas;
	}

	public void setGas(String gas) {
		this.gas = gas;
	}

	public String getGasPrice() {
		return gasPrice;
	}

	public void setGasPrice(String gasPrice) {
		this.gasPrice = gasPrice;
	}

	public String getIsError() {
		return isError;
	}

	public void setIsError(String isError) {
		this.isError = isError;
	}

	public String getContractAddress() {
		return contractAddress;
	}

	public void setContractAddress(String contractAddress) {
		this.contractAddress = contractAddress;
	}

	public String getGasUsed() {
		return gasUsed;
	}

	public void setGasUsed(String gasUsed) {
		this.gasUsed = gasUsed;
	}

	public static long getSerialversionuid() {
		return serialVersionUID;
	}

	public String getSymbol() {
		return symbol;
	}

	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}

	@Override
	public String toString() {
		return "TransactionHistory [blockNumber=" + blockNumber + ", timeStamp=" + timeStamp + ", hash=" + hash + ", from=" + from + ", to=" + to + ", value=" + value + ", gas=" + gas + ", gasPrice=" + gasPrice + ", isError=" + isError + ", contractAddress=" + contractAddress + ", gasUsed=" + gasUsed + ", symbol=" + symbol + "]";
	}

}
				
				
			</pre><pre class="programlisting">
				
package api.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import api.domain.TransactionHistory;

@Repository
public interface TransactionHistoryRepository extends CrudRepository&lt;TransactionHistory, Integer&gt; {

	@Query(value = "SELECT * FROM transaction_history th WHERE (th.from_address = :address or th.to_address = :address) and contract_address is NULL",
			countQuery = "SELEÇT count(*) FROM transaction_history th WHERE (th.from_address = :address or th.to_address = :address) and contract_address is NULL",
			nativeQuery = true)
	public Page&lt;TransactionHistory&gt; findEthByAddress(@Param("address") String address, Pageable pageable);

}
				
			</pre></section><section class="section" id="id1146"><div class="titlepage"><div><div><h3 class="title">返回指定字段</h3></div></div></div><p>通过实体返回数据有时结果集非常庞大，可能会影响性能，这时我们只需要返回指定字段即可。</p><pre class="programlisting">
				
@Query(value = "select u.userName, ui.name, ui.gender, ui.description from UserInfo ui, User u where u.id = ui.userId")
public List&lt;Object&gt; getCustomField();
				
			</pre></section><section class="section" id="id1147"><div class="titlepage"><div><div><h3 class="title">返回指定的模型</h3></div></div></div><p>临时写一个新的模型</p><pre class="programlisting">
				
public class MyModel implements Serializable {

    private String userName;
    private String name;
    private String gender;
    private String description;

    public MyModel() {};

    public MyModel(String userName, String name, String gender, String description) {
        this.userName = userName;
        this.name = name;
        this.gender = gender;
        this.description = description;
    }
}
				
			</pre><p>使用构造方法赋值</p><pre class="programlisting">
				
@Query(value = "select new cn.netkiller.model.MyModel(u.userName, ui.name, ui.gender, ui.description) from UserInfo ui, User u where u.id = ui.userId")
public List&lt;MyModel&gt; getAllRecord();
				
			</pre></section><section class="section" id="Query.Collection"><div class="titlepage"><div><div><h3 class="title">Collection</h3></div></div></div><p>返回集合</p><pre class="programlisting">
				
@Query("SELECT u FROM User u WHERE u.status = 1")
Collection&lt;User&gt; findAllActiveUsers();				
				
			</pre><p>处理子查询 IN</p><pre class="programlisting">
			
@Query(value = "SELECT u FROM User u WHERE u.name IN :names")
List&lt;User&gt; findUserByNameList(@Param("names") Collection&lt;String&gt; names);			
			
			</pre></section><section class="section" id="nativeQuery"><div class="titlepage"><div><div><h3 class="title">原生SQL查询</h3></div></div></div><p>这里的nativeQuery=true代表在执行这个方法的时候使用原生sql语句，直接写数据库中的实际表名和表中的字段名，而不是实体表名。
			</p><pre class="programlisting">
				
    @Modifying
    @Query(nativeQuery = true, value = "UPDATE project p, (SELECT MIN(start) AS start, MAX(finish) AS finish FROM project WHERE parent_id = :id) t SET p.start = t.start, p.finish = t.finish WHERE p.id = :id")
    public void updateStartAndFinishById(@Param("id") Long id);				
				
			</pre><p>在什么情况下使用呢？例如上面，同时操作两张表，做更新，如果不使用 nativeQuery = true 无法实现。
			</p></section><section class="section" id="Sort"><div class="titlepage"><div><div><h3 class="title">Sort</h3></div></div></div><pre class="programlisting">
		
	@Query(value = "SELECT u FROM User u")
	List&lt;User&gt; findAllUsers(Sort sort);		
		
			</pre></section><section class="section" id="@Lock"><div class="titlepage"><div><div><h3 class="title">锁 @Lock</h3></div></div></div><pre class="programlisting">
			
interface UserRepository extends Repository&lt;User, Long&gt; {

  // Plain query method
  @Lock(LockModeType.READ)
  List&lt;User&gt; findByLastname(String lastname);			
			
			</pre></section></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch52s04.xhtml">上一页</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch52.xhtml">上一级</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="../redis/ch53.xhtml">下一页</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">TransactionTemplate </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="../../index.xhtml">起始页</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> 第 53 章 Spring Data with Redis</td></tr></table></div></footer></body></html>