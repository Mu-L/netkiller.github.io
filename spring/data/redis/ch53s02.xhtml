<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>RedisTemplate</title><link rel="stylesheet" type="text/css" href="../../docbook.css"/><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"/><meta name="keywords" content="Spring, Spring Boot, Spring Cloud, Spring Eureka, Spring Config"/><link rel="prev" href="ch53.xhtml" title="第 53 章 Spring Data with Redis"/><link rel="next" href="ch53s03.xhtml" title="Spring Data Redis - Repository Examples"/></head><body><header><div class="navheader"><table style="width: 100%; "><tr><th style="text-align: center; " colspan="3">RedisTemplate</th></tr><tr><td style="width: 20%; text-align: left; "><a accesskey="p" href="ch53.xhtml">上一页</a> </td><th style="width: 60%; text-align: center; ">第 53 章 Spring Data with Redis</th><td style="width: 20%; text-align: right; "> <a accesskey="n" href="ch53s03.xhtml">下一页</a></td></tr></table><hr/></div></header><section class="section" id="RedisTemplate"><div class="titlepage"><div><div><h2 class="title" style="clear: both">RedisTemplate</h2></div></div></div><section class="section" id="stringRedisTemplate"><div class="titlepage"><div><div><h3 class="title">stringRedisTemplate 基本用法</h3></div></div></div><pre class="screen">
			
stringRedisTemplate.opsForValue().set("test", "100",60*10,TimeUnit.SECONDS);	//向redis里存入数据和设置缓存时间
stringRedisTemplate.opsForValue().get("test")									//根据key获取缓存中的val
stringRedisTemplate.getExpire("test")											//根据key获取过期时间
stringRedisTemplate.getExpire("test",TimeUnit.SECONDS)							//根据key获取过期时间并换算成指定单位
stringRedisTemplate.delete("test");												//根据key删除缓存
stringRedisTemplate.hasKey("546545");											//检查key是否存在，返回boolean值
stringRedisTemplate.expire("test",1000 , TimeUnit.MILLISECONDS);				//设置过期时间	
			
			</pre></section><section class="section" id="id1153"><div class="titlepage"><div><div><h3 class="title">设置缓存时间</h3></div></div></div><pre class="programlisting">
			
例子：设置 name 缓存 10 秒

redisTemplate.opsForValue().set("name","neo",10, TimeUnit.SECONDS);
redisTemplate.opsForValue().get("name")

结果：由于设置的是10秒失效，十秒之内查询有结果，十秒之后返回为null			
			
			</pre></section><section class="section" id="id1154"><div class="titlepage"><div><div><h3 class="title">字符串截取</h3></div></div></div><pre class="programlisting">
			
设置：redisTemplate.opsForValue().set("hello","Helloworld");
代码：System.out.println(redisTemplate.opsForValue().get("hello",0,5));
结果：Hellow
代码：System.out.println(redisTemplate.opsForValue().get("hello",0,-1));
结果：Helloworld
代码：System.out.println(redisTemplate.opsForValue().get("hello",-3,-1));
结果：rld			
			
			</pre></section><section class="section" id="id1155"><div class="titlepage"><div><div><h3 class="title">追加字符串</h3></div></div></div><pre class="programlisting">
			
redisTemplate.opsForValue().append("hello","Hello");
System.out.println(redisTemplate.opsForValue().get("hello"));

redisTemplate.opsForValue().append("hello","world");
System.out.println(redisTemplate.opsForValue().get("hello")); // 结果：Helloworld        			
			
			</pre></section><section class="section" id="id1156"><div class="titlepage"><div><div><h3 class="title">设置键的字符串值并返回其旧值</h3></div></div></div><pre class="programlisting">
			
	redisTemplate.opsForValue().set("name","neo");
    System.out.println(redisTemplate.opsForValue().getAndSet("name","Jerry"));
	// 结果 neo			
			
			</pre></section><section class="section" id="id1157"><div class="titlepage"><div><div><h3 class="title">increment</h3></div></div></div><pre class="screen">
			
stringRedisTemplate.opsForValue().set("test", "100");							//向redis里存入数据			
stringRedisTemplate.boundValueOps("test").increment(-50);						//val做-60操作
stringRedisTemplate.boundValueOps("test").increment(100);						//val +100
stringRedisTemplate.opsForValue().get("test")									//根据key获取缓存中的val		
			
			</pre></section><section class="section" id="delete"><div class="titlepage"><div><div><h3 class="title">删除 key </h3></div></div></div><pre class="programlisting">
		
	private void cleanNewToday() {
		long begin = System.currentTimeMillis();
        
		redisTemplate.delete("news:today");
    
        long end = System.currentTimeMillis();
		logger.info("Schedule clean redis {} 耗时 {} 秒", "cleanNewFlash()", (end-begin) / 1000 );
	}
		
			</pre></section><section class="section" id="size"><div class="titlepage"><div><div><h3 class="title">返回字符串长度</h3></div></div></div><pre class="programlisting">
			
redisTemplate.opsForValue().set("key","hello world");
System.out.println(redisTemplate.opsForValue().size("key"));			
			
			</pre></section><section class="section" id="setIfAbsent"><div class="titlepage"><div><div><h3 class="title">如果key不存便缓存。</h3></div></div></div><pre class="programlisting">
			
System.out.println(redisTemplate.opsForValue().setIfAbsent("name","neo"));	// name 之前已经存在 false
System.out.println(redisTemplate.opsForValue().setIfAbsent("age","11"));		// age 之前不存在	true
			
			</pre><p>setIfAbsent 实现分布式锁</p><pre class="programlisting">
			
boolean static = Boolean.TRUE.equals(redisTemplate.opsForValue().setIfAbsent("lock:order", 1, 1, TimeUnit.DAYS));			
			
			</pre></section><section class="section" id="multiSet"><div class="titlepage"><div><div><h3 class="title">缓存多个值 /获取多个值 multiSet / multiGet</h3></div></div></div><pre class="programlisting">
			
Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
	maps.put("multi1","multi1");
	maps.put("multi2","multi2");
	maps.put("multi3","multi3");

redisTemplate.opsForValue().multiSet(maps);

List&lt;String&gt; keys = new ArrayList&lt;String&gt;();
	keys.add("multi1");
	keys.add("multi2");
	keys.add("multi3");

System.out.println(redisTemplate.opsForValue().multiGet(keys));			
			
			</pre><p>输出结果</p><pre class="screen">
			
[multi1, multi2, multi3]			
			
			</pre><p>为多个键分别设置它们的值，如果存在则返回false，不存在返回true</p><pre class="programlisting">
			
Map&lt;String,String&gt; maps = new HashMap&lt;String, String&gt;();
        maps.put("multi11","multi11");
        maps.put("multi22","multi22");
        maps.put("multi33","multi33");
Map&lt;String,String&gt; maps2 = new HashMap&lt;String, String&gt;();
        maps2.put("multi1","multi1");
        maps2.put("multi2","multi2");
        maps2.put("multi3","multi3");

System.out.println(redisTemplate.opsForValue().multiSetIfAbsent(maps)); 	// 返回 true
System.out.println(redisTemplate.opsForValue().multiSetIfAbsent(maps2));	// 返回 false
			
			</pre></section><section class="section" id="list"><div class="titlepage"><div><div><h3 class="title">List</h3></div></div></div><section class="section" id="id1158"><div class="titlepage"><div><div><h4 class="title">rightPush</h4></div></div></div><pre class="programlisting">
			
ListOperations&lt;String, Object&gt; list = redisTemplate.opsForList();
list.rightPush("books", "Linux");
list.rightPush("books", "Java");
System.out.println(list.range("books", 0, 1));

System.out.println(redisTemplate.opsForList().size("list"));
			
				</pre></section><section class="section" id="id1159"><div class="titlepage"><div><div><h4 class="title">rightPushAll</h4></div></div></div><pre class="programlisting">
				
		String[] stringarrays = new String[]{"1","2","3"};
        redisTemplate.opsForList().rightPushAll("listarrayright",stringarrays);
        System.out.println(redisTemplate.opsForList().range("listarrayright",0,-1));				
				
				</pre><pre class="programlisting">
				
		List&lt;Object&gt; strings = new ArrayList&lt;Object&gt;();
        strings.add("1");
        strings.add("2");
        strings.add("3");
        redisTemplate.opsForList().rightPushAll("listcollectionright", strings);
        System.out.println(redisTemplate.opsForList().range("listcollectionright",0,-1));				
				
				</pre></section><section class="section" id="id1160"><div class="titlepage"><div><div><h4 class="title">rightPushIfPresent</h4></div></div></div><pre class="programlisting">
				
		System.out.println("========== KEY 不存在===========");
		System.out.println(redisTemplate.opsForList().rightPushIfPresent("rightPushIfPresent","aa"));
        System.out.println(redisTemplate.opsForList().rightPushIfPresent("rightPushIfPresent","bb"));
        System.out.println("========== KEY 已经存在===========");
        System.out.println(redisTemplate.opsForList().rightPushIfPresent("rightPushIfPresent","aa"));
        System.out.println(redisTemplate.opsForList().rightPushIfPresent("rightPushIfPresent","bb"));				
				
				</pre></section><section class="section" id="id1161"><div class="titlepage"><div><div><h4 class="title">leftPush</h4></div></div></div><pre class="programlisting">
			
redisTemplate.opsForList().leftPush("list","java");
redisTemplate.opsForList().leftPush("list","python");
redisTemplate.opsForList().leftPush("list","c++");			
			
				</pre></section><section class="section" id="id1162"><div class="titlepage"><div><div><h4 class="title">leftPushAll</h4></div></div></div><p>批量把一个数组插入到列表中</p><pre class="programlisting">
				
	String[] stringarrays = new String[]{"1","2","3"};
    redisTemplate.opsForList().leftPushAll("listarray",stringarrays);	
				
				</pre><p>批量把一个集合插入到列表中</p><pre class="programlisting">
			
使用：List&lt;Object&gt; strings = new ArrayList&lt;Object&gt;();
        strings.add("1");
        strings.add("2");
        strings.add("3");
        redisTemplate.opsForList().leftPushAll("listcollection", strings);
        System.out.println(redisTemplate.opsForList().range("listcollection",0,-1));
结果:[3, 2, 1]			
			
				</pre></section><section class="section" id="id1163"><div class="titlepage"><div><div><h4 class="title">range</h4></div></div></div><pre class="programlisting">
			
    System.out.println(redisTemplate.opsForList().range("listarray",0,-1));
	// 结果:[3, 2, 1]				
			
				</pre></section></section><section class="section" id="set"><div class="titlepage"><div><div><h3 class="title">SET 数据类型</h3></div></div></div><p>Redis的Set是无序集合并且集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><pre class="screen">
			
stringRedisTemplate.opsForSet().add("test", "1","2","3");						//向指定key中存放set集合
stringRedisTemplate.opsForSet().isMember("test", "1")							//根据key查看集合中是否存在指定数据
stringRedisTemplate.opsForSet().members("test");								//根据key获取set集合				
			
			</pre><pre class="programlisting">
		
//添加 一个 set 集合
SetOperations&lt;String, Object&gt; set = redisTemplate.opsForSet();
set.add("Member", "neo");
set.add("Member", "36");
set.add("Member", "178cm");
//输出 set 集合
System.out.println(set.members("Member"));	
		
			</pre><pre class="programlisting">
		
package cn.netkiller.api.restful;

import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import common.pojo.ResponseRestful;

@RestController
@RequestMapping("/news")
public class NewsRestController {

	@Autowired
	private RedisTemplate&lt;String, String&gt; redisTemplate;

	@RequestMapping(value = "/flash/{count}")
	public ResponseRestful flash(@PathVariable("count") long count) {
		if(count == 0L) {
			count=10L;
		}
		Set&lt;String&gt; news = this.redisTemplate.opsForZSet().reverseRange("news:flash", 0, count);
		if (news == null) {
			return new ResponseRestful(false, 10, "没有查询到结果", news);
		}
		return new ResponseRestful(true, 0, "返回数据: " + news.size() + " 条", news);
	}
	
	public void addRecentUser(long userId, String name) {  
	    String key = RedisKeyGenerator.genRecentBrowsingPositionsKey(String.valueOf(userId));  
	    // 获取已缓存的最近浏览的职位  
	    ZSetOperations&lt;String, String&gt; zSetOperations = redisTempalte.opsForZSet();  
        //zset内部是按分数来排序的，这里用当前时间做分数  
	    zSetOperations.add(key, name, System.currentTimeMillis());  
	    zSetOperations.removeRange(key, 0, -6);  
	}  
	
}
		
			</pre><section class="section" id="id1164"><div class="titlepage"><div><div><h4 class="title">返回集合中的所有成员</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForSet().members("setTest"));				
				
				</pre></section><section class="section" id="id1165"><div class="titlepage"><div><div><h4 class="title">取出一个成员</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForSet().pop("setTest"));				
				
				</pre></section><section class="section" id="id1166"><div class="titlepage"><div><div><h4 class="title">随机获取无序集合中的一个元素</h4></div></div></div><pre class="programlisting">
				
System.out.println("Random member: " + redisTemplate.opsForSet().randomMember("setTest"));				
				
				</pre></section><section class="section" id="id1167"><div class="titlepage"><div><div><h4 class="title">随机获取 n 个成员（存在重复数据）</h4></div></div></div><pre class="programlisting">
				
System.out.println("Random member: " + redisTemplate.opsForSet().randomMembers("setTest",5));
// 结果 Random member: [ccc, ddd, ddd, ddd, aaa]				
				
				</pre></section><section class="section" id="id1168"><div class="titlepage"><div><div><h4 class="title">随机获取 n 个不重复成员</h4></div></div></div><pre class="programlisting">
				
System.out.println("Random members: " + redisTemplate.opsForSet().distinctRandomMembers("setTest",5));
//结果 Random members: [aaa, bbb, ddd, ccc]				
				
				</pre></section><section class="section" id="id1169"><div class="titlepage"><div><div><h4 class="title">在两个 SET 间移动数据</h4></div></div></div><pre class="programlisting">
				
	redisTemplate.opsForSet().move("key1","aaa","key2");
	System.out.println(redisTemplate.opsForSet().members("key1"));
    System.out.println(redisTemplate.opsForSet().members("key2"));				
				
				</pre></section><section class="section" id="id1170"><div class="titlepage"><div><div><h4 class="title">成员删除</h4></div></div></div><pre class="programlisting">
				
String[] arrays = new String[]{"Java","PHP"};
System.out.println(redisTemplate.opsForSet().remove("setTest",arrays));				
				
				</pre></section><section class="section" id="id1171"><div class="titlepage"><div><div><h4 class="title">返回集合数量</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForSet().size("setTest"));				
				
				</pre></section><section class="section" id="id1172"><div class="titlepage"><div><div><h4 class="title">判断元素是否在集合成员中</h4></div></div></div><pre class="programlisting">
				
ystem.out.println(redisTemplate.opsForSet().isMember("setTest","Linux"));				
				
				</pre></section><section class="section" id="id1173"><div class="titlepage"><div><div><h4 class="title">对比两个集合求交集</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForSet().members("key"));
    System.out.println(redisTemplate.opsForSet().members("otherKey"));
    System.out.println(redisTemplate.opsForSet().intersect("key","otherKey"));				
				
				</pre><pre class="programlisting">
				
        List&lt;String&gt; library2 = new ArrayList&lt;String&gt;();
        library2.add("Linux");
        library2.add("FreeBSD");
        System.out.println(redisTemplate.opsForSet().intersect("library1",library2));				
				
				</pre></section><section class="section" id="id1174"><div class="titlepage"><div><div><h4 class="title">对比两个集合求交集，然后存储到新的 key 中</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForSet().intersectAndStore("key","otherKey","destKey"));				
				
				</pre><pre class="programlisting">
				
		List&lt;String&gt; otherKey = new ArrayList&lt;String&gt;();
        otherKey.add("《Netkiller Java 手札》");
        otherKey.add("《Netkiller Spring Cloud 手札》");
        System.out.println(redisTemplate.opsForSet().intersectAndStore("key",otherKey,"destKey"));				
				
				</pre></section><section class="section" id="id1175"><div class="titlepage"><div><div><h4 class="title">合并两个集合，并去处重复数据</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForSet().union("setTest1","setTest2"));
	
	List&lt;String&gt; otherKey = new ArrayList&lt;String&gt;();
    otherKey.add("《Netkiller Java 手札》");
    otherKey.add("《Netkiller Spring Cloud 手札》");
    System.out.println(redisTemplate.opsForSet().union("setTest",otherKey));		
				
				</pre></section><section class="section" id="id1176"><div class="titlepage"><div><div><h4 class="title">合并两个集合去重复后保存到新的 key 中</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForSet().unionAndStore("key","otherKey","destKey"));
	System.out.println(redisTemplate.opsForSet().unionAndStore("key",otherKey,"destKey"));					
				
				</pre></section><section class="section" id="id1177"><div class="titlepage"><div><div><h4 class="title">计算两个合集的差集</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForSet().difference("key","otherKey"));		
	
	List&lt;String&gt; otherKey = new ArrayList&lt;String&gt;();
    otherKey.add("setTest2");
    otherKey.add("setTest3");
    System.out.println(redisTemplate.opsForSet().difference("key",otherKey));		
				
				</pre></section><section class="section" id="id1178"><div class="titlepage"><div><div><h4 class="title">计算两个合集的差集，然后保存到新的 key 中</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForSet().differenceAndStore("key","otherKey","destKey"));
				
				</pre></section><section class="section" id="id1179"><div class="titlepage"><div><div><h4 class="title">遍历 SET 集合</h4></div></div></div><pre class="programlisting">
				
	Cursor&lt;Object&gt; curosr = redisTemplate.opsForSet().scan("setTest", ScanOptions.NONE);
    while(curosr.hasNext()){
        System.out.println(curosr.next());
    }				
				
				</pre></section></section><section class="section" id="zset"><div class="titlepage"><div><div><h3 class="title">有序的 set 集合</h3></div></div></div><pre class="programlisting">
			
//添加有序的 set 集合
ZSetOperations&lt;String, Object&gt; zset = redisTemplate.opsForZSet();
zset.add("zMember", "neo", 0);
zset.add("zMember", "36", 1);
zset.add("zMember", "178cm", 2);
//输出有序 set 集合
System.out.println(zset.rangeByScore("zMember", 0, 2));				
			
			</pre></section><section class="section" id="hash"><div class="titlepage"><div><div><h3 class="title">Hash</h3></div></div></div><section class="section" id="id1180"><div class="titlepage"><div><div><h4 class="title">put</h4></div></div></div><pre class="programlisting">
				
	redisTemplate.opsForHash().put("redisHash","name","neo");
    redisTemplate.opsForHash().put("redisHash","age",30);
    redisTemplate.opsForHash().put("redisHash","nickname","netkiller");				
				
				</pre></section><section class="section" id="id1181"><div class="titlepage"><div><div><h4 class="title">putAll</h4></div></div></div><pre class="programlisting">
				
HashOperations&lt;String, Object, Object&gt;  hash = redisTemplate.opsForHash();
Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put("name", "neo");
map.put("age", "36");
hash.putAll("member", map);

System.out.println(hash.entries("member"));		
				
				</pre></section><section class="section" id="id1182"><div class="titlepage"><div><div><h4 class="title">从键中的哈希获取给定hashKey的值</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForHash().get("redisHash","age"));				
				
				</pre></section><section class="section" id="id1183"><div class="titlepage"><div><div><h4 class="title">delete</h4></div></div></div><p>删除指定的哈希 hashKeys</p><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForHash().delete("redisHash","name"));
				
				</pre></section><section class="section" id="id1184"><div class="titlepage"><div><div><h4 class="title">确定哈希hashKey是否存在</h4></div></div></div><p>确定哈希hashKey是否存在</p><pre class="programlisting">
				
System.out.println(redisTemplate.opsForHash().hasKey("redisHash","age"));				
				
				</pre></section><section class="section" id="id1185"><div class="titlepage"><div><div><h4 class="title">从哈希中获取指定的多个 hashKey 的值</h4></div></div></div><pre class="programlisting">
				
	List&lt;Object&gt; keys = new ArrayList&lt;Object&gt;();
    keys.add("name");
    keys.add("age");
    System.out.println(redisTemplate.opsForHash().multiGet("redisHash",keys))				
				
				</pre></section><section class="section" id="id1186"><div class="titlepage"><div><div><h4 class="title">只有hashKey不存在时才能添加值</h4></div></div></div><pre class="programlisting">
				
	System.out.println(redisTemplate.opsForHash().putIfAbsent("redisHash","age",30));				
				
				</pre></section><section class="section" id="id1187"><div class="titlepage"><div><div><h4 class="title">获取整个Hash</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForHash().entries("redisHash"));					
				
				</pre></section><section class="section" id="id1188"><div class="titlepage"><div><div><h4 class="title">获取所有key</h4></div></div></div><pre class="programlisting">
				

System.out.println(redisTemplate.opsForHash().keys("redisHash1"));				
				
				</pre></section><section class="section" id="id1189"><div class="titlepage"><div><div><h4 class="title">通过 hashKey 获取所有值</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForHash().values("redisHash"));				
				
				</pre></section><section class="section" id="id1190"><div class="titlepage"><div><div><h4 class="title">值加法操作</h4></div></div></div><pre class="programlisting">
				
System.out.println(redisTemplate.opsForHash().increment("redisHash","age",1)				
				
				</pre></section><section class="section" id="id1191"><div class="titlepage"><div><div><h4 class="title">遍历 Hash 表</h4></div></div></div><pre class="programlisting">
				
	Cursor&lt;Map.Entry&lt;Object, Object&gt;&gt; curosr = redisTemplate.opsForHash().scan("redisHash", ScanOptions.ScanOptions.NONE);
	while(curosr.hasNext()){
	    Map.Entry&lt;Object, Object&gt; entry = curosr.next();
	    System.out.println(entry.getKey()+":"+entry.getValue());
	}				
				
				</pre></section></section><section class="section" id="redisTemplate.expire"><div class="titlepage"><div><div><h3 class="title">过期时间未执行</h3></div></div></div><p>Spring Redis 中设置过期时间方法如下</p><pre class="programlisting">
		
设置 key
redisTemplate.opsForValue().setIfAbsent("key", "value");
设置过期时间
redisTemplate.expire("key", 30000, TimeUnit.MILLISECONDS);
释放 key
redisTemplate.delete("key");		
		
			</pre><p>这样存在一个问题，当程序运行一半被强行终止，可能导致setIfAbsent运行完成，但是expire未被执行，这样 key 便永远不会释放。解决方案如下，使用RedisCallback执行原生 Redis 命令。</p><pre class="programlisting">
		
String result = redisTemplate.execute(new RedisCallback&lt;String&gt;() {
	@Override
	public String doInRedis(RedisConnection connection) throws DataAccessException {
		JedisCommands commands = (JedisCommands) connection.getNativeConnection();
		return commands.set(key, value, "NX", "PX", expire);
	}
});		
		
			</pre></section><section class="section" id="id1192"><div class="titlepage"><div><div><h3 class="title">setBit / getBit 二进制位操作</h3></div></div></div><pre class="screen">
			
setBit Boolean setBit(K key, long offset, boolean value);

offset 二进制位置(从左向右数)
value 位 ture 表示 0，false 表示 1			
			
			</pre><pre class="programlisting">
			
    // 'a' 的ASCII码是 97 转换为二进制是：01100001
    // 'b' 的ASCII码是 98 转换为二进制是：01100010
    // 'c' 的ASCII码是 99 转换为二进制是：01100011
    			
	redisTemplate.opsForValue().set("bitTest","a");    
    
    redisTemplate.opsForValue().setBit("bitTest",7, false); 	// 01100011
    redisTemplate.opsForValue().setBit("bitTest",8, true);	// 01100010
    System.out.println(redisTemplate.opsForValue().get("bitTest"));
    redisTemplate.opsForValue().setBit("bitTest",8, false);	// 01100011
    System.out.println(redisTemplate.opsForValue().get("bitTest"));			
			
			</pre><p>getBit Boolean getBit(K key, long offset); 获取键对应值的ascii码的在offset处位值</p><pre class="programlisting">
			
System.out.println(redisTemplate.opsForValue().getBit("bitTest",7));			
			
			</pre></section><section class="section" id="JsonRedisTemplate"><div class="titlepage"><div><div><h3 class="title">存储 Json 对象</h3></div></div></div><section class="section" id="id1193"><div class="titlepage"><div><div><h4 class="title">集成 RedisTemplate 定义新类 JsonRedisTemplate</h4></div></div></div><pre class="programlisting">
			
package cn.netkiller.wallet.redis;

import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import com.fasterxml.jackson.databind.ObjectMapper;

public class JsonRedisTemplate extends RedisTemplate&lt;String, Object&gt; {

	public JsonRedisTemplate(RedisConnectionFactory connectionFactory, ObjectMapper objectMapper, Class&lt;?&gt; valueType) {
		RedisSerializer&lt;String&gt; stringSerializer = new StringRedisSerializer();
		super.setKeySerializer(stringSerializer);
		super.setHashKeySerializer(stringSerializer);
		super.setHashValueSerializer(stringSerializer);
		Jackson2JsonRedisSerializer&lt;?&gt; jsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(valueType);
		jsonRedisSerializer.setObjectMapper(objectMapper);
		super.setValueSerializer(jsonRedisSerializer);
		super.setConnectionFactory(connectionFactory);
		super.afterPropertiesSet();
	}
}
			
			
				</pre></section><section class="section" id="id1194"><div class="titlepage"><div><div><h4 class="title">配置 Redis</h4></div></div></div><pre class="programlisting">
			
package cn.netkiller.wallet.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.listener.ChannelTopic;
import org.springframework.data.redis.listener.RedisMessageListenerContainer;
import org.springframework.data.redis.listener.adapter.MessageListenerAdapter;

import com.fasterxml.jackson.databind.ObjectMapper;

import cn.netkiller.wallet.redis.JsonRedisTemplate;
import cn.netkiller.wallet.redis.RedisMessageSubscriber;

@Configuration
public class RedisConfig {

	public RedisConfig() {
	}

	@Bean
	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory connectionFactory) {
		StringRedisTemplate redisTemplate = new StringRedisTemplate();
		redisTemplate.setConnectionFactory(connectionFactory);
		return redisTemplate;
	}

	@Bean
	public MessageListenerAdapter messageListener() {
		return new MessageListenerAdapter(new RedisMessageSubscriber());
	}

	@Bean
	public ChannelTopic topic() {
		return new ChannelTopic("demo");
	}

	@Bean
	public RedisMessageListenerContainer redisContainer(RedisConnectionFactory connectionFactory, MessageListenerAdapter messageListener) {
		RedisMessageListenerContainer container = new RedisMessageListenerContainer();

		container.setConnectionFactory(connectionFactory);
		container.addMessageListener(messageListener(), topic());
		container.addMessageListener(messageListener(), new ChannelTopic("test"));
		return container;
	}

	@Bean
	public ObjectMapper objectMapper() {
		return new ObjectMapper();
	}

	@Bean
	public JsonRedisTemplate jsonRedisTemplate(RedisConnectionFactory connectionFactory, ObjectMapper objectMapper) {
		return new JsonRedisTemplate(connectionFactory, objectMapper, Object.class);
	}

}
			
			
				</pre></section><section class="section" id="id1195"><div class="titlepage"><div><div><h4 class="title">测试</h4></div></div></div><pre class="programlisting">
			
package cn.netkiller.wallet.restful;

import java.io.IOException;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.listener.ChannelTopic;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import cn.netkiller.wallet.pojo.RestfulResponse;
import cn.netkiller.wallet.redis.JsonRedisTemplate;
import cn.netkiller.wallet.redis.RedisMessagePublisher;

@RestController
public class TestRestController {
	private static final Logger logger = LoggerFactory.getLogger(TestRestController.class);

	@Autowired
	private StringRedisTemplate stringRedisTemplate;

	@Autowired
	private JsonRedisTemplate jsonRedisTemplate;

	public TestRestController() {

	}

	@GetMapping("/version")
	public String version() throws IOException {
		Web3ClientVersion web3ClientVersion = web3j.web3ClientVersion().send();
		String clientVersion = web3ClientVersion.getWeb3ClientVersion();
		logger.info(clientVersion);
		return clientVersion;
	}

	@GetMapping("/pub/demo")
	public String pub() {

		RedisMessagePublisher publisher = new RedisMessagePublisher(stringRedisTemplate, new ChannelTopic("demo"));
		String message = "Message " + UUID.randomUUID();
		publisher.publish(message);
		return message;
	}

	@GetMapping("/pub/test")
	public String pub(@RequestParam String message) {

		RedisMessagePublisher publisher = new RedisMessagePublisher(stringRedisTemplate, new ChannelTopic("test"));
		publisher.publish(message);
		return message;
	}

	@GetMapping("/pub/json")
	public RestfulResponse pubJson() {
		RestfulResponse restfulResponse = new RestfulResponse(true, 0, null, null);
		jsonRedisTemplate.opsForValue().set("test", restfulResponse);
		jsonRedisTemplate.convertAndSend("test", restfulResponse);
		return restfulResponse;
	}
}
			
				</pre></section></section></section><footer><div class="navfooter"><hr/><table style="width: 100%; "><tr><td style="width: 40%; text-align: left; "><a accesskey="p" href="ch53.xhtml">上一页</a> </td><td style="width: 20%; text-align: center; "><a accesskey="u" href="ch53.xhtml">上一级</a></td><td style="width: 40%; text-align: right; "> <a accesskey="n" href="ch53s03.xhtml">下一页</a></td></tr><tr><td style="width: 40%; text-align: left; vertical-align: top; ">第 53 章 Spring Data with Redis </td><td style="width: 20%; text-align: center; "><a accesskey="h" href="../../index.xhtml">起始页</a></td><td style="width: 40%; text-align: right; vertical-align: top; "> Spring Data Redis - Repository Examples</td></tr></table></div></footer></body></html>