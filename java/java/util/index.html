<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.3. Util</title><link rel="stylesheet" type="text/css" href="../../docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="../../index.html" title="Netkiller Java 手札（版）" /><link rel="up" href="../jdk.html" title="第 8 章 JDK Development Kit" /><link rel="prev" href="../sql/index.html" title="8.2. JDBC" /><link rel="next" href="../io/index.html" title="8.4. IO" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> | <a xmlns="" href="//netkiller.github.io/">简体中文</a> | <a xmlns="" href="http://netkiller.sourceforge.net/">繁体中文</a> | <a xmlns="" href="/journal/index.html">杂文</a>
		| <a xmlns="" href="https://github.com/netkiller">Github</a> | <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> | <a xmlns="" href="https://edu.51cto.com/lecturer/1703915.html">51CTO学院</a> | <a xmlns="" href="https://edu.csdn.net/lecturer/6423">CSDN程序员研修院</a> | <a xmlns="" href="http://my.oschina.net/neochen/">OSChina 博客</a> | <a xmlns="" href="https://cloud.tencent.com/developer/column/2078">腾讯云社区</a> | <a xmlns="" href="https://yq.aliyun.com/u/netkiller/">阿里云栖社区</a> | <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> | <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> | <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> | <a xmlns="" href="//www.netkiller.cn/home/donations.html">打赏(Donations)</a> | <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.3. Util</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../sql/index.html">上一页</a> </td><th width="60%" align="center">第 8 章 JDK Development Kit</th><td width="20%" align="right"> <a accesskey="n" href="../io/index.html">下一页</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a></td><td></td><td></td><td></td><td></td></tr></table><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="index"></a>8.3. Util</h2></div></div></div>
	
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.Properties"></a>8.3.1. Properties 处理 *.properties 文件</h3></div></div></div>
		
		<pre class="programlisting">
		
package netkiller.test;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.FileInputStream;
import java.util.Properties;

public class PropertiesTest {

	public static void main(String[] args) {

		System.out.println("Working Directory = " + System.getProperty("user.dir"));

		Properties ps = new Properties();
		try {
			ps.load(new FileInputStream("netkiller.properties"));
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println(ps.getProperty("key"));
	}

}
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49383186256"></a>8.3.1.1. 打开 properties 文件</h4></div></div></div>
			
			<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idm49383185616"></a>文件方式打开</h5></div></div></div>
				
				<pre class="programlisting">
				
BufferedReader br = null;
Properties properties = new Properties();
br = new BufferedReader(new InputStreamReader(new  FileInputStream(new File("data.properties")), "UTF8"));
properties.load(br);				
				
				</pre>
			</div>
			<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idm49383184096"></a>输入流</h5></div></div></div>
				
				<pre class="programlisting">
				
Properties properties = new Properties();
InputStream in = getClass().getResourceAsStream("/IcisReport.properties");
properties.load(in);
Set keyValue = properties.keySet();
for (Iterator it = keyValue.iterator(); it.hasNext();)
{
	String key = (String) it.next();
}				
				
				</pre>
			</div>

		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="propertyNames"></a>8.3.1.2. propertyNames()</h4></div></div></div>
			
			<pre class="programlisting">
			
package cn.netkiller.properties;

import java.util.Enumeration;
import java.util.Map.Entry;
import java.util.Properties;

public class PropertiesTest {

	public PropertiesTest() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Properties properties = new Properties();

		properties.put("K1", "V1");
		properties.put("K2", "V2");

		for (Entry&lt;Object, Object&gt; x : properties.entrySet()) {
			System.out.println(x.getKey() + " " + x.getValue());
		}
		
		Enumeration&lt;?&gt; e = properties.propertyNames();
		while (e.hasMoreElements()) {
			String key = (String) e.nextElement();
			String value = properties.getProperty(key);
			System.out.println(key + ": " + value);
		}
	}

}
			
			</pre>
			<pre class="programlisting">
			
import java.io.FileInputStream;
import java.util.Enumeration;
import java.util.Properties;

public class MainClass {
  public static void main(String args[]) throws Exception {
    Properties p = new Properties();
    p.load(new FileInputStream("test.properties"));
    Enumeration e = p.propertyNames();

    for (; e.hasMoreElements();) {
      System.out.println(e.nextElement());

    }
  }
}			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49385134192"></a>8.3.1.3. keySet()</h4></div></div></div>
			
			<pre class="programlisting">
			
package cn.netkiller.properties;

import java.util.Properties;
import java.util.Set;

public class PropertiesTest {

	public PropertiesTest() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Properties properties = new Properties();

		properties.put("K1", "V1");
		properties.put("K2", "V2");

		Set&lt;Object&gt; states = properties.keySet();

		for (Object name : states)
			System.out.println("The value of " + name + " is " + properties.getProperty((String) name) + ".");
	}

}

			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49385132384"></a>8.3.1.4. entrySet()</h4></div></div></div>
			
			<pre class="programlisting">
			
package cn.netkiller.properties;

import java.util.Map.Entry;
import java.util.Properties;

public class PropertiesTest {

	public PropertiesTest() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Properties properties = new Properties();

		properties.put("K1", "V1");
		properties.put("K2", "V2");

		for (Entry&lt;Object, Object&gt; x : properties.entrySet()) {
			System.out.println(x.getKey() + " " + x.getValue());
		}
	}

}
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49385130704"></a>8.3.1.5. 方法中返回 Properties</h4></div></div></div>
			
			<pre class="programlisting">
			
	@RequestMapping("/host")
	public Enumeration&lt;Object&gt; host() throws IOException {
		Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource(String.format("/%s.properties", "host")));
		return properties.keys();
	}

	@RequestMapping("/mail")
	public Collection&lt;Object&gt; mail() throws IOException {
		Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource(String.format("/%s.properties", "mail")));
		return properties.values();
	}
	@RequestMapping("/nameserver")
	public Set&lt;Entry&lt;Object, Object&gt;&gt; nameserver() throws IOException {
		Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource(String.format("/%s.properties", "dns")));
		return properties.entrySet();
	}
	@RequestMapping("/dns")
	public Properties dns() throws IOException {
		Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource(String.format("/%s.properties", "dns")));
		return properties;
	}	
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49385129552"></a>8.3.1.6. </h4></div></div></div>
			
			<pre class="programlisting">
			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="getResourceAsStream"></a>8.3.1.7. getResourceAsStream()</h4></div></div></div>
			
			<pre class="programlisting">
			
Properties prop = new Properties();
prop.load(getServletContext().getResourceAsStream("/WEB-INF/resource/sample.properties"));
			
			</pre>
			<pre class="programlisting">
			
prop.load(Thread.currentThread().getContextClassLoader().getResourceAsStream("netkiller.properties"));
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="store"></a>8.3.1.8. store</h4></div></div></div>
			
			<pre class="programlisting">
			
package cn.netkiller.config;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Properties;

public class Config {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Properties prop = new Properties();
		OutputStream output = null;

		try {

			output = new FileOutputStream("config.properties");

			// set the properties value
			prop.setProperty("host", "localhost");
			prop.setProperty("port", "8000");
			prop.setProperty("user", "neo");
			prop.setProperty("pass", "password");

			// save properties to project root folder
			prop.store(output, null);

		} catch (IOException io) {
			io.printStackTrace();
		} finally {
			if (output != null) {
				try {
					output.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}

		}
	}

}
			
			</pre>
			<p>getProperty 取出key的值</p>
			<pre class="programlisting">
			
package cn.netkiller.config;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class LoadConfig {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Properties prop = new Properties();
		InputStream input = null;

		try {

			input = new FileInputStream("config.properties");

			// load a properties file
			prop.load(input);

			// get the property value and print it out
			System.out.println(prop.getProperty("host"));
			System.out.println(prop.getProperty("port"));
			System.out.println(prop.getProperty("user"));
			System.out.println(prop.getProperty("pass"));

		} catch (IOException ex) {
			ex.printStackTrace();
		} finally {
			if (input != null) {
				try {
					input.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

	}

}
			
			</pre>
			<p>循环打印所有 Properties 内容</p>
			<pre class="programlisting">
			
package test;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;

public class Application {

	public static void main(String[] args) {
		Application app = new Application();
		app.config();

	}

	private void config() {
		Properties prop = new Properties();
		InputStream input = null;
		try {

			String filename = "config.properties";

			prop.load(new FileInputStream(filename));

			Enumeration&lt;?&gt; e = prop.propertyNames();
			while (e.hasMoreElements()) {
				String key = (String) e.nextElement();
				String value = prop.getProperty(key);
				System.out.println(key + ": " + value);
			}

		} catch (IOException ex) {
			ex.printStackTrace();
		} finally {
			if (input != null) {
				try {
					input.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

}
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49385120848"></a>8.3.1.9. 实现国际化</h4></div></div></div>
			
			<p>准备语言包文件 chinese.properties 内容如下</p>
			<pre class="screen">
			
hello=你好世界
			
			</pre>
			<p>english.properties</p>
			<pre class="screen">
			
hello=Helloworld
			
			</pre>
			<pre class="programlisting">
			 
	@GetMapping("/lang")
	public String lang(@RequestHeader String lang) throws IOException {
		System.out.println(lang);
		Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource(lang + ".properties"));
		String tmp = properties.getProperty("hello");
		return tmp;
	}
			 
			</pre>
			<p>测试效果</p>
			<pre class="screen">
			
curl -s -H lang:chinese http://localhost:8080/lang
你好世界

curl -s -H lang:english http://localhost:8080/lang
Helloworld
			
			</pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.logging"></a>8.3.2. Logging</h3></div></div></div>
		
		<pre class="programlisting">
		
import java.util.logging.*;
public class Main {
	public static void main(String[] args) {
		Logger log = Logger.getLogger("test"); 
        log.setLevel(Level.INFO); 
        log.info("--------------------------");
        log.info("Test");
        log.info("--------------------------");
        
	}
}
		
		</pre>
		<p>XML</p>
		<pre class="programlisting">
		
import java.io.IOException;
import java.util.logging.*;

public class Main {
	public static void main(String[] args) {

		try {
			Logger log = Logger.getLogger("test");
			FileHandler fileHandler = new FileHandler("test.%g.log");
			fileHandler.setLevel(Level.INFO);
			log.addHandler(fileHandler);
			
			log.setLevel(Level.INFO);
			log.info("One");
			log.info("Two");
			log.info("Three");
			
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}		
		
		</pre>
		<p>XML 输出结果</p>
		<pre class="programlisting">
		
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE log SYSTEM "logger.dtd"&gt;
&lt;log&gt;
&lt;record&gt;
  &lt;date&gt;2016-04-19T15:57:19&lt;/date&gt;
  &lt;millis&gt;1461052639360&lt;/millis&gt;
  &lt;sequence&gt;0&lt;/sequence&gt;
  &lt;logger&gt;test&lt;/logger&gt;
  &lt;level&gt;INFO&lt;/level&gt;
  &lt;class&gt;Main&lt;/class&gt;
  &lt;method&gt;main&lt;/method&gt;
  &lt;thread&gt;1&lt;/thread&gt;
  &lt;message&gt;One&lt;/message&gt;
&lt;/record&gt;
&lt;record&gt;
  &lt;date&gt;2016-04-19T15:57:19&lt;/date&gt;
  &lt;millis&gt;1461052639394&lt;/millis&gt;
  &lt;sequence&gt;1&lt;/sequence&gt;
  &lt;logger&gt;test&lt;/logger&gt;
  &lt;level&gt;INFO&lt;/level&gt;
  &lt;class&gt;Main&lt;/class&gt;
  &lt;method&gt;main&lt;/method&gt;
  &lt;thread&gt;1&lt;/thread&gt;
  &lt;message&gt;Two&lt;/message&gt;
&lt;/record&gt;
&lt;record&gt;
  &lt;date&gt;2016-04-19T15:57:19&lt;/date&gt;
  &lt;millis&gt;1461052639395&lt;/millis&gt;
  &lt;sequence&gt;2&lt;/sequence&gt;
  &lt;logger&gt;test&lt;/logger&gt;
  &lt;level&gt;INFO&lt;/level&gt;
  &lt;class&gt;Main&lt;/class&gt;
  &lt;method&gt;main&lt;/method&gt;
  &lt;thread&gt;1&lt;/thread&gt;
  &lt;message&gt;Three&lt;/message&gt;
&lt;/record&gt;
&lt;/log&gt;
		
		</pre>
		<p>Formatter 日志格式化</p>
		<pre class="programlisting">
		
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.*;

class LogFormatter extends Formatter {
	@Override
	public String format(LogRecord record) {
		return String.format("%s %s\t%s\n", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date()) , record.getLevel(), record.getMessage());
	}
}

public class Main {
	public static void main(String[] args) {

		try {
			Logger log = Logger.getLogger("test");
			FileHandler fileHandler = new FileHandler("test.%g.log");
			fileHandler.setLevel(Level.INFO);
			log.addHandler(fileHandler);
			fileHandler.setFormatter(new LogFormatter());
			log.setLevel(Level.INFO);
			log.info("One");
			log.info("Two");
			log.info("Three");

		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}		
		
		</pre>
		<p>输出样式</p>
		<pre class="programlisting">
		
2016-04-19 16:05:53.324 INFO	One
2016-04-19 16:05:53.352 INFO	Two
2016-04-19 16:05:53.353 INFO	Three		
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49384304608"></a>8.3.2.1. console</h4></div></div></div>
			
			<p>控制台日志输入格式定义</p>
			<pre class="programlisting">
				ConsoleHandler consoleHandler = new ConsoleHandler();
				consoleHandler.setLevel(Level.OFF);
				logger.addHandler(consoleHandler);
			</pre>
			<p>禁止 Console 输出</p>
			<pre class="programlisting">
				logger.setUseParentHandlers(false);
			</pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.Base64"></a>8.3.3. BASE64</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller.test;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class Base64Test {
	public static void main(String[] args) {
		final String text = "http://www.netkiller.cn/index.html";

		final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));
		System.out.println(encoded);

		final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);
		System.out.println(decoded);
	}
}
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.Locale"></a>8.3.4. Locale 国际化</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller.i18n;

import java.util.Locale;

public class Lang {

	public Lang() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		// create a new locale
		Locale locale = new Locale("ENGLISH", "US");

		// print locale
		System.out.println("Locale:" + locale);

		// print display name for locale - based on inLocale
		System.out.println("Name:" + locale.getDisplayName(new Locale("GERMAN", "GERMANY")));

	}

}
		
		</pre>
		<pre class="programlisting">
		
Locale locale = new Locale("zh", "CN");
Locale locale = Locale.US;
Locale locale = Locale.getDefault();	// 默认语言	
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.ResourceBundle"></a>8.3.5. ResourceBundle</h3></div></div></div>
		
		<pre class="programlisting">
		
java.util.ResourceBundle resourceBundle = java.util.ResourceBundle.getBundle("message");

resourceBundle.getString("nickname");	

// 指定语言

Locale  locale = new Locale("zh", "CN");
ResourceBundle res = ResourceBundle.getBundle("message", locale);	
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Scanner"></a>8.3.6. Scanner</h3></div></div></div>
		
		<pre class="programlisting">
		
Scanner in = new Scanner(System.in);
System.out.println("Username:");
String username = in.next();
		
		</pre>
	</div>

	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.UUID"></a>8.3.7. UUID</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller.example.uuid;

import java.util.UUID;

public class UuidTest {

	public UuidTest() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		UUID uuid = UUID.randomUUID();
		String randomUUIDString = uuid.toString();

		System.out.println("Random UUID String = " + randomUUIDString);
		System.out.println("UUID version       = " + uuid.version());
		System.out.println("UUID variant       = " + uuid.variant());
	}

}
		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Arrays.equals"></a>8.3.8. Arrays.equals 判断两个数组是否相等</h3></div></div></div>
		
		<p>static boolean equals(type[] a, type[] b)</p>
		<pre class="programlisting">
		
Arrays.equals(array1, array2)		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.Random"></a>8.3.9. Random 随机字符串</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller.test;

import java.util.Random;

public class QueueTest {

	public static void main(String[] args) throws InterruptedException {
		new Random().ints(10, 33, 38).forEach(System.out::println);
	}
}
		
		
		</pre>
		<pre class="screen">
		
36
34
34
36
37
35
34
35
34
33
		
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399767984"></a>8.3.9.1. 取 0-n 范围内随机数</h4></div></div></div>
			
			<pre class="programlisting">
			
    private int salt() {
        Random random = new Random();
        return random.nextInt(99999999);
    }			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399766704"></a>8.3.9.2. 指定随机数范围</h4></div></div></div>
			
			<pre class="programlisting">
			
package cn.netkiller.test;

import java.util.Random;

public class RandomTest {

	public static int random(int min, int max) {
		var value = new Random().ints(min, (max + 1)).limit(1).findFirst().getAsInt();
		return value;
	}

	public static void main(String[] args) throws InterruptedException {
		System.out.println(random(10, 15));
	}
}
			
			
			</pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="concurrent"></a>8.3.10. ArrayBlockingQueue</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller.test;

import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class QueueTest {
	/**
	 * 定义装苹果的篮子
	 */
	public static class Basket {
		// 篮子，能够容纳10个苹果
		BlockingQueue&lt;String&gt; basket = new ArrayBlockingQueue&lt;String&gt;(10);

		// 生产苹果，放入篮子
		public void produce() throws InterruptedException {
			// put方法放入一个苹果，若basket满了，等到basket有位置
			basket.put("An apple");
		}

		// 消费苹果，从篮子中取走
		public String consume() throws InterruptedException {
			// get方法取出一个苹果，若basket为空，等到basket有苹果为止
			return basket.take();
		}

		public int size() {
			return basket.size();
		}

	}

	// 测试方法
	public static void testBasket() throws InterruptedException {
		// 建立一个装苹果的篮子
		final Basket basket = new Basket();
		// 定义苹果生产者
		class Producer implements Runnable {
			public void run() {
				try {
					while (true) {
						int n = random(1, 5);
						for (int i = 0; i &lt; n; i++) {
							basket.produce();
						}
						System.out.println(System.currentTimeMillis() + " 放入" + n + "个，当前总数：" + basket.size() + "个");
						Thread.sleep(random(450, 1000));
					}
				} catch (InterruptedException ex) {
				}
			}
		}
		// 定义苹果消费者
		class Consumer implements Runnable {
			public void run() {
				try {
					while (true) {
						// 消费苹果
						int n = random(1, 5);
						for (int i = 0; i &lt; n; i++) {
							basket.consume();
						}
						System.out.println(System.currentTimeMillis() + " 取出" + n + "个，剩余数量：" + basket.size() + "个");
						Thread.sleep(random(400, 1000));
					}
				} catch (InterruptedException ex) {
				}
			}
		}

		ExecutorService service = Executors.newCachedThreadPool();
		Producer producer = new Producer();
		Consumer consumer = new Consumer();
		service.submit(producer);
		// 延迟消费
		Thread.sleep(5000);
		service.submit(consumer);
		// 程序运行10s后，所有任务停止
		try {
			Thread.sleep(20000);
		} catch (InterruptedException e) {
		}
		service.shutdownNow();
	}

	public static int random(int min, int max) {
		var value = new Random().ints(min, (max + 1)).limit(1).findFirst().getAsInt();
		return value;
	}

	public static void main(String[] args) throws InterruptedException {
		QueueTest.testBasket();
	}
}

		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.zip.CRC32"></a>8.3.11. CRC32</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller.security;

import java.nio.ByteBuffer;
import java.util.zip.CRC32;

public class CRC {

	public static void main(String[] args) {

		final CRC32 crc32 = new CRC32();
		ByteBuffer data = ByteBuffer.wrap("http://www.netkiller.cn".getBytes());
		crc32.update(data);
		System.out.println(crc32.getValue());

	}

}		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.regex"></a>8.3.12. 正则表达式</h3></div></div></div>
		
		<pre class="programlisting">
		
package cn.netkiller;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test {


    public static void main(String[] args) {

        Pattern pattern = Pattern.compile("www|netkiller");
        Matcher matcher = pattern.matcher("http://www.netkiller.cn/linux/index.html");
        if (matcher.find()) {
            System.out.println(matcher.group());
        }

    }
}
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399760384"></a>8.3.12.1. 正则查找</h4></div></div></div>
			
			<p></p>
			<pre class="programlisting">
			
        Matcher matcher = Pattern.compile("播放|暂停|停止").matcher("当前暂停音乐");

        if(matcher.find()){
            System.out.println(matcher.group(0));
        }
        
        if(Pattern.compile("播放|暂停|停止").matcher("当前停音乐").find()){
            System.out.println("查找到");
        }
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399758624"></a>8.3.12.2. 正则替换</h4></div></div></div>
			
			<pre class="programlisting">
			
package cn.netkiller;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test {

    public static void main(String[] args) {

        Pattern pattern = Pattern.compile("www|netkiller");
        Matcher matcher = pattern.matcher("https://www.netkiller.cn/linux/index.html");
        if (matcher.find()) {
            String s = matcher.replaceFirst("api"); //替换后的字符串
            System.out.println(s);
        }

    }
}			
			
			</pre>
			<pre class="programlisting">
			
package cn.netkiller;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Test {


    public static void main(String[] args) {

        Pattern pattern = Pattern.compile("www|netkiller");
        Matcher matcher = pattern.matcher("https://www.netkiller.cn/linux/index.html");
        if (matcher.find()) {
            String s = matcher.replaceAll("test"); //替换后的字符串
            System.out.println(s);
            // 输出结果：https://test.test.cn/linux/index.html
        }

    }
}
			
			</pre>
			<p></p>
			<pre class="programlisting">
			
"aab".replaceAll("a{1}", "x"); //xxb
"aba".replaceAll("a{1}", "x"); //xbx

"abaaabaaaba".replaceAll("a{2}", "x");  //abxabxaba
"abaabaaaaba".replaceAll("a{2}", "x"); //abxbxxba			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399755136"></a>8.3.12.3. 字符串分割</h4></div></div></div>
			
			<pre class="programlisting">
			
        String input = "苹果!!香蕉!!鸭梨!!橘子";
        System.out.println(Arrays.toString(Pattern.compile("!!").split(input)));
        System.out.println(Arrays.toString(Pattern.compile("!!").split(input, 3)));
			
			</pre>
			<pre class="screen">
			
[苹果, 香蕉, 鸭梨, 橘子]
[苹果, 香蕉, 鸭梨!!橘子]			
			
			</pre>
		</div>
		
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="java.util.concurrent"></a>8.3.13. java.util.concurrent</h3></div></div></div>
	
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399752240"></a>8.3.13.1. TimeUnit</h4></div></div></div>
		
		<pre class="programlisting">
		
	try {
		TimeUnit.SECONDS.sleep(5);
	} catch (InterruptedException e) {
	}		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="java.util.concurrent.FutureTask"></a>8.3.13.2. FutureTask</h4></div></div></div>
		
		<pre class="programlisting">
	
package cn.netkiller.welcome;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Future {

	public static void main(String[] args) throws InterruptedException, ExecutionException {
		// TODO Auto-generated method stub
		FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;String&gt;() {
			@Override
			public String call() throws Exception {
				String status = null;
				System.out.println(Thread.currentThread().getName() + ":" + "Send SMS ...");
				Thread.sleep(2000);
				System.out.println(Thread.currentThread().getName() + ":" + "Sent");
				status = "OK";
				return status;
			}
		});

//		开启了一个线程执行future的逻辑
		Thread thread = new Thread(futureTask);
		thread.start();

		// 主业务逻辑
		System.out.println(Thread.currentThread().getName() + ":" + "Begin");
		Thread.sleep(3000);
		System.out.println(Thread.currentThread().getName() + ":" + "End");

		String sent = futureTask.get();

		System.out.println(Thread.currentThread().getName() + ":" + "Status：" + sent + " done!");
	}

}
	
	
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="CompletableFuture"></a>8.3.13.3. CompletableFuture</h4></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="runAsync"></a>runAsync 创建没有返回值的异步任务</h5></div></div></div>
			
			<p>runAsync 创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是自定义线程池的重载方法</p>
			<pre class="programlisting">
			
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture.runAsync(() -&gt; {
            System.out.println("do something...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture.runAsync(() -&gt; {
            System.out.println("do something...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }, executorService);

        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {
            System.out.println("do something....");
//            Thread.currentThread().setName("测试有返回值的异步执行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("Result -&gt;" + completableFuture.isDone());


    }
}
			
			</pre>
			<p></p>
			<pre class="screen">
			
do something...
do something...
do something....

=======================================================================================
|   ID |                             Name | Group | Daemon |         State | Priority |
---------------------------------------------------------------------------------------
|    1 |                             main |  main |  false |      RUNNABLE |        5 |
|   21 | ForkJoinPool.commonPool-worker-1 |  main |   true | TIMED_WAITING |        5 |
|   22 |                  pool-1-thread-1 |  main |  false | TIMED_WAITING |        5 |
|   23 | ForkJoinPool.commonPool-worker-2 |  main |   true | TIMED_WAITING |        5 |
=======================================================================================

Result -&gt;true
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="supplyAsync"></a>supplyAsync 创建带有返回值的异步任务。</h5></div></div></div>
			
			<p>supplyAsync 创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法</p>
			<pre class="screen">
			
// 带返回值异步请求，默认线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)
 
// 带返回值的异步请求，可以自定义线程池
public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)			
			
			</pre>
			<pre class="programlisting">
			
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("do something....");
            return "done";
        });

        System.out.println("Result -&gt;" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}			
			
			</pre>
			<p>运行结果</p>
			<pre class="screen">
			
do something....
Result -&gt;done
=======================================================================================
|   ID |                             Name | Group | Daemon |         State | Priority |
---------------------------------------------------------------------------------------
|    1 |                             main |  main |  false |      RUNNABLE |        5 |
|   21 | ForkJoinPool.commonPool-worker-1 |  main |   true | TIMED_WAITING |        5 |
=======================================================================================		
			
			</pre>
			<pre class="programlisting">
			
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {


        ExecutorService executorService = Executors.newSingleThreadExecutor();

        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("do something....");
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "done";
        }, executorService);

        System.out.println("Result -&gt;" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}
			
			</pre>
			<p>运行结果</p>
			<pre class="screen">
			
do something....
Result -&gt;done
======================================================================
|   ID |            Name | Group | Daemon |         State | Priority |
----------------------------------------------------------------------
|    1 |            main |  main |  false |      RUNNABLE |        5 |
|   21 | pool-1-thread-1 |  main |  false |       WAITING |        5 |
======================================================================			
			
			</pre>
			<p>设置线程名称</p>
			<pre class="programlisting">
			
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("do something....");
            Thread.currentThread().setName("测试有返回值的异步执行");
            return "done";
        });

        System.out.println("Result -&gt;" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}			
			
			</pre>
			<p>运行结果</p>
			<pre class="screen">
			
do something....
Result -&gt;done
==================================================================
|   ID |        Name | Group | Daemon |         State | Priority |
------------------------------------------------------------------
|    1 |        main |  main |  false |      RUNNABLE |        5 |
|   21 | 测试有返回值的异步执行 |  main |   true | TIMED_WAITING | 5 |
==================================================================	
			
			</pre>
		</div>
		
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="Run"></a>thenRun / thenRunAsync</h5></div></div></div>
			
			<p>thenRun/thenRunAsync 功能是什么？完成前置任务之后，自己在执行。</p>
			<p>thenRun/thenRunAsync 区别是什么？thenRun 使用同一个线程执行任务，thenRunAsync 会再开一个新线程执行任务。</p>
			<pre class="programlisting">
			
    @GetMapping("/completableFutureRun")
    public String completableFutureRun() {
        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        CompletableFuture thenRun = completableFuture.thenRun(() -&gt; {
            System.out.println(Thread.currentThread().getName() + " - 接着执行第二个 thenRun 任务");
        });
        CompletableFuture thenRunAsync = completableFuture.thenRunAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + " - 接着执行第二个 thenRunAsync 任务");
        });
        return "Done";
    }			
			
			</pre>
			<p>运行结果</p>
			<pre class="screen">
			
ForkJoinPool.commonPool-worker-1 - CompletableFuture 前置任务
ForkJoinPool.commonPool-worker-1 - 接着执行第二个 thenRun 任务
ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenRunAsync 任务
			
			</pre>
			<p>这里可以看到 thenRunAsync 的线程变化，开启新线程 ForkJoinPool.commonPool-worker-2 处理任务</p>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="Accept"></a>thenAccept / thenAcceptAsync</h5></div></div></div>
			
			<p>thenAccept/thenAcceptAsync 的功能是，前置任务执行完毕之后，将返回值给到 thenAccept/thenAcceptAsync，再执行接下来的任务。</p>
			<pre class="programlisting">
			
    @GetMapping("/completableFutureAccept")
    public String completableFutureAccept() {
        CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; {
            log.info(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "前置任务执行完成";
        });
        CompletableFuture&lt;Void&gt; thenAccept = supplyAsync.thenAccept((rev) -&gt; {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenAccept 任务");
            log.info("前置任务返回值：" + rev);
        });
        CompletableFuture&lt;Void&gt; thenAcceptAsync = supplyAsync.thenAcceptAsync((rev) -&gt; {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenAcceptAsync 任务");
            log.info("前置任务返回值：" + rev);
        });
        return "Done";
    }			
			
			</pre>
			<p>输出结果</p>
			<pre class="screen">
			
2023-05-10T10:38:48.008+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-1 - CompletableFuture 前置任务
2023-05-10T10:38:53.015+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenAcceptAsync 任务
2023-05-10T10:38:53.015+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-1 - 接着执行第二个 thenAccept 任务
2023-05-10T10:38:53.016+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : 前置任务返回值：前置任务执行完成
2023-05-10T10:38:53.016+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : 前置任务返回值：前置任务执行完成			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="Apply"></a>thenApply / thenApplyAsync</h5></div></div></div>
			
			<p>thenApply/thenApplyAsync 前置任务执行完毕之后，结果作为入参，thenApply/thenApplyAsync 执行完毕之后再返回执行结果</p>
			<pre class="programlisting">
			
    @GetMapping("/completableFutureApply")
    public String completableFutureApply() throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; supplyAsync = CompletableFuture.supplyAsync(() -&gt; {
            log.info(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "第一步";
        });

        CompletableFuture&lt;String&gt; thenApply = supplyAsync.thenApply((rev) -&gt; {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenApply 任务");
            log.info("前置任务返回值：" + rev);
            return "第二步";
        });

        CompletableFuture&lt;String&gt; thenApplyAsync = supplyAsync.thenApplyAsync((rev) -&gt; {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenApplyAsync 任务");
            log.info("前置任务返回值：" + rev);
            return "第二步";
        });
        log.info("supplyAsync：{}", supplyAsync.get());
        log.info("thenApply：{}", thenApply.get());
        log.info("thenApplyAsync：{}", thenApplyAsync.get());
        return "Done";
    }			
			
			</pre>
			<p></p>
			<pre class="screen">
			
2023-05-10T10:39:57.913+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - CompletableFuture 前置任务
2023-05-10T10:40:02.917+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : XNIO-1 task-2 - 接着执行第二个 thenApply 任务
2023-05-10T10:40:02.917+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenApplyAsync 任务
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : 前置任务返回值：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : 前置任务返回值：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : supplyAsync：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : thenApply：第二步
2023-05-10T10:40:02.919+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : thenApplyAsync：第二步
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="runAsync"></a>runAsync / thenAccept / thenApply 区别</h5></div></div></div>
			
			<p>runAsync 配合 thenRun/thenRunAsync 使用</p>
			<p>supplyAsync 配合 thenAccept/thenAcceptAsync 使用</p>
			<pre class="screen">
			
supplyAsync -- 返回值 --&gt; thenAccept/thenAcceptAsync --&gt; 无返回值
			
			</pre>
			<p>supplyAsync 配合 thenApply/thenApplyAsync 使用</p>
			<pre class="screen">
			
supplyAsync -- 返回值 --&gt; thenApply/thenApplyAsync -- 返回值 --&gt;			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="whenComplete"></a>whenComplete</h5></div></div></div>
			
			<p>whenComplete 与 runAsync / thenAccept / thenApply 区别是能处理 Throwable</p>
			<pre class="programlisting">
			
    @GetMapping("/completableFutureWhenComplete")
    public String completableFutureWhenComplete() throws ExecutionException, InterruptedException {

        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("当前线程名称：" + Thread.currentThread().getName());
            return "前置任务完成";
        }).whenComplete((result, throwable) -&gt; {
            System.out.println("前置任务返回值：" + result);
        });
        System.out.println(completableFuture.get());
        return "Done";
    }			
			
			</pre>
			<p>运行结果</p>
			<pre class="screen">
			
当前线程名称：ForkJoinPool.commonPool-worker-1
前置任务返回值：前置任务完成
前置任务完成			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="completeOnTimeout"></a>超时处理</h5></div></div></div>
			
			<pre class="programlisting">
			
		CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "hello";
        });

        future.completeOnTimeout("default timeout result", 3 * 1000, TimeUnit.MILLISECONDS);			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="thenCompose"></a>按顺序执行</h5></div></div></div>
			
			<pre class="programlisting">
			
@Service
public class MyService {

    @Async("threadPoolTaskExecutor")
    public CompletableFuture&lt;String&gt; asyncMethod1() {
        // 异步方法1逻辑...
        return CompletableFuture.completedFuture("Result1");
    }

    @Async("threadPoolTaskExecutor")
    public CompletableFuture&lt;String&gt; asyncMethod2() {
        // 异步方法2逻辑...
        return CompletableFuture.completedFuture("Result2");
    }
}

// 调用异步方法并处理结果顺序 
CompletableFuture&lt;String&gt; future1 = myService.asyncMethod1(); 
CompletableFuture&lt;String&gt; future2 = future1.thenCompose(result1 -&gt; myService.asyncMethod2());

String finalResult = future2.get(); // 阻塞等待最终结果	
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="get"></a>获取结果</h5></div></div></div>
			
			<pre class="programlisting">
			
@Service
public class MyService {

    @Async
    public CompletableFuture&lt;String&gt; asyncMethod() {
        // 异步方法逻辑...
        return CompletableFuture.completedFuture("Result");
    }
}

// 调用异步方法并获取结果
CompletableFuture&lt;String&gt; future = myService.asyncMethod();
String result = future.get(); // 阻塞等待结果			
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="exceptionally"></a>异常处理</h5></div></div></div>
			
			<pre class="programlisting">
			
@Service
public class MyService {

    @Async
    public CompletableFuture&lt;String&gt; asyncMethod() {
        try {
            // 异步方法逻辑...
            return CompletableFuture.completedFuture("Success");
        } catch (Exception e) {
            // 处理异常...
            return CompletableFuture.failedFuture(e);
        }
    }
}

// 调用异步方法并处理异常
CompletableFuture&lt;String&gt; future = myService.asyncMethod();
future.exceptionally(e -&gt; {
    // 异常处理逻辑...
    return "Error";
});

			
			</pre>
			<pre class="programlisting">
			
    @GetMapping("/completableFutureExceptionally")
    public String completableFutureExceptionally() throws ExecutionException, InterruptedException {

        CompletableFuture.supplyAsync(() -&gt; {
            System.out.println("当前线程名称：" + Thread.currentThread().getName());
            throw new RuntimeException();
        }).exceptionally((e) -&gt; {
            System.out.println(e.getMessage());
            return "程序出现异常";
        });

//        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
////            throw new RuntimeException();
//            return "程序出现异常";
//        }).exceptionally((e) -&gt; {
//            System.out.println("程序出现异常");
//            return "程序出现异常";
//        });
//        System.out.println(completableFuture.get());

        return "Done";
    }			
			
			</pre>
			<p>输出结果</p>
			<pre class="screen">
			
当前线程名称：ForkJoinPool.commonPool-worker-1
java.lang.RuntimeException			
			
			</pre>
		</div>
	</div>
</div>
	
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="idm49399748704"></a>8.3.14. java.util.stream</h3></div></div></div>
	
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm49399705072"></a>8.3.14.1. IntStream</h4></div></div></div>
		
		<pre class="programlisting">
		
		List&lt;Picture&gt; list = new ArrayList&lt;Picture&gt;();
		
		IntStream.range(1, 10).forEach(i -&gt; {
            Picture picture = new Picture();
            picture.setId(Long.valueOf(i));
            picture.setImage("https://www.netkiller.cn/images/" + i + ".png");
            list.add(picture);
        });		
		
		</pre>
	</div>
</div>
</div><div xmlns="" id="SOHUCS"></div><script xmlns="" charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js"></script><script xmlns="" type="text/javascript">
			window.changyan.api.config({
			appid: 'cyvwjQUG3',
			conf: 'prod_ef966242df3d8b5acb1e0ee9fc01cafe'
			});
</script><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="../sql/index.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="../jdk.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="../io/index.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">8.2. JDBC </td><td width="20%" align="center"><a accesskey="h" href="../../index.html">起始页</a></td><td width="40%" align="right" valign="top"> 8.4. IO</td></tr></table></div><script xmlns="">
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-11694057-1', 'auto');
			ga('send', 'pageview');

		</script><script xmlns="" async="async">
			var _hmt = _hmt || [];
			(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
			})();
</script><script xmlns="" async="async">
			(function(){
			var bp = document.createElement('script');
			var curProtocol = window.location.protocol.split(':')[0];
			if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
			}
			else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
			}
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(bp, s);
			})();
</script></body></html>