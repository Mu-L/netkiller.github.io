<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第 8 章 数据结构</title><link rel="stylesheet" type="text/css" href="../../docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="../../index.html" title="Netkiller Java 手札（版）" /><link rel="up" href="../index.html" title="部分 II. JDK Development Kit" /><link rel="prev" href="../index.html" title="部分 II. JDK Development Kit" /><link rel="next" href="java.util.List.html" title="8.2. List" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> | <a xmlns="" href="//netkiller.github.io/">简体中文</a> | <a xmlns="" href="http://netkiller.sourceforge.net/">繁体中文</a> | <a xmlns="" href="/journal/index.html">杂文</a>
		| <a xmlns="" href="https://github.com/netkiller">Github</a> | <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> | <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> | <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> | <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> | <a xmlns="" href="//www.netkiller.cn/home/donations.html">打赏(Donations)</a> | <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 8 章 数据结构</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../index.html">上一页</a> </td><th width="60%" align="center">部分 II. JDK Development Kit</th><td width="20%" align="right"> <a accesskey="n" href="java.util.List.html">下一页</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a></td><td></td><td></td><td></td><td></td></tr></table><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="index"></a>第 8 章 数据结构</h2></div></div></div><div class="toc"><p><strong>目录</strong></p><dl class="toc"><dt><span class="section"><a href="index.html#Collection">8.1. Collection 接口</a></span></dt><dt><span class="section"><a href="java.util.List.html">8.2. List</a></span></dt><dd><dl><dt><span class="section"><a href="java.util.List.html#id820">8.2.1. 静态 List</a></span></dt><dt><span class="section"><a href="java.util.List.html#List.of()">8.2.2. List.of()</a></span></dt><dt><span class="section"><a href="java.util.List.html#List.copyOf()">8.2.3. List.copyOf()</a></span></dt><dt><span class="section"><a href="java.util.List.html#Arrays.asList">8.2.4. String[] to List</a></span></dt><dt><span class="section"><a href="java.util.List.html#Collectors.toList">8.2.5. Stream.toList() 方法</a></span></dt><dt><span class="section"><a href="java.util.List.html#list.containsAll">8.2.6. containsAll</a></span></dt><dt><span class="section"><a href="java.util.List.html#stream.allMatch">8.2.7. stream().allMatch()</a></span></dt><dt><span class="section"><a href="java.util.List.html#随机获取List元素">8.2.8. 随机 List</a></span></dt><dt><span class="section"><a href="java.util.List.html#getFirst">8.2.9. getFirst() / getLast()</a></span></dt><dt><span class="section"><a href="java.util.List.html#List.toArray">8.2.10. List 转 Array</a></span></dt></dl></dd><dt><span class="section"><a href="ArrayList.html">8.3. ArrayList</a></span></dt><dd><dl><dt><span class="section"><a href="ArrayList.html#id821">8.3.1. 初始化</a></span></dt><dt><span class="section"><a href="ArrayList.html#id822">8.3.2. 判断元素是否存在</a></span></dt><dt><span class="section"><a href="ArrayList.html#id823">8.3.3. 循环打印</a></span></dt><dt><span class="section"><a href="ArrayList.html#id824">8.3.4. ArrayList to Array</a></span></dt><dt><span class="section"><a href="ArrayList.html#id825">8.3.5. ArrayList to String</a></span></dt><dt><span class="section"><a href="ArrayList.html#id826">8.3.6. Array to List</a></span></dt><dt><span class="section"><a href="ArrayList.html#id827">8.3.7. List to Array</a></span></dt><dt><span class="section"><a href="ArrayList.html#arrayList.forEach">8.3.8. ArrayList forEach</a></span></dt><dt><span class="section"><a href="ArrayList.html#ArrayList.stream()">8.3.9. ArrayList stream()</a></span></dt><dt><span class="section"><a href="ArrayList.html#ArrarList2String">8.3.10. ArrarList 转换为 string[]</a></span></dt><dt><span class="section"><a href="ArrayList.html#StringToArrayList">8.3.11. string 转换为 ArrayList</a></span></dt><dt><span class="section"><a href="ArrayList.html#id828">8.3.12. ArrayList 转换为 string</a></span></dt><dt><span class="section"><a href="ArrayList.html#id829">8.3.13. string[] 转换为 ArrarList</a></span></dt><dt><span class="section"><a href="ArrayList.html#id830">8.3.14. 合并 List&lt;byte[]&gt; ArrayList&lt;byte[]&gt;</a></span></dt></dl></dd><dt><span class="section"><a href="LinkedList.html">8.4. LinkedList</a></span></dt><dt><span class="section"><a href="Vector.html">8.5. Vector</a></span></dt><dt><span class="section"><a href="set.html">8.6. Set</a></span></dt><dd><dl><dt><span class="section"><a href="set.html#id831">8.6.1. Set 初始化</a></span></dt><dt><span class="section"><a href="set.html#id832">8.6.2. Set 转为 List</a></span></dt><dt><span class="section"><a href="set.html#Set.of()">8.6.3. Set.of()</a></span></dt><dt><span class="section"><a href="set.html#Set.toArray">8.6.4. Set to Array</a></span></dt></dl></dd><dt><span class="section"><a href="map.html">8.7. Map</a></span></dt><dd><dl><dt><span class="section"><a href="map.html#Map.of">8.7.1. 初始化</a></span></dt><dt><span class="section"><a href="map.html#HashMap">8.7.2. HashMap</a></span></dt><dt><span class="section"><a href="map.html#LinkedHashMap">8.7.3. LinkedHashMap</a></span></dt><dt><span class="section"><a href="map.html#Map.loop">8.7.4. 遍历数据</a></span></dt><dt><span class="section"><a href="map.html#Map.Iterator">8.7.5. 迭代器</a></span></dt><dt><span class="section"><a href="map.html#map.forEach">8.7.6. Map forEach</a></span></dt><dt><span class="section"><a href="map.html#Map随机取值">8.7.7. 随机取值</a></span></dt></dl></dd><dt><span class="section"><a href="Iterator.html">8.8. Iterator 迭代器</a></span></dt><dd><dl><dt><span class="section"><a href="Iterator.html#id843">8.8.1. List 迭代</a></span></dt><dt><span class="section"><a href="Iterator.html#id844">8.8.2. 处理剩余结果</a></span></dt><dt><span class="section"><a href="Iterator.html#id845">8.8.3. Map 迭代</a></span></dt><dt><span class="section"><a href="Iterator.html#id846">8.8.4. Iterator 与 List 的区别</a></span></dt><dt><span class="section"><a href="Iterator.html#id847">8.8.5. remove() 删除操作</a></span></dt><dt><span class="section"><a href="Iterator.html#id848">8.8.6. Iterable 转 List</a></span></dt></dl></dd><dt><span class="section"><a href="ListIterator.html">8.9. ListIterator</a></span></dt><dt><span class="section"><a href="java.util.Queue.html">8.10. Queue</a></span></dt><dd><dl><dt><span class="section"><a href="java.util.Queue.html#id849">8.10.1. 阻塞队列</a></span></dt><dt><span class="section"><a href="java.util.Queue.html#LinkedBlockingQueue">8.10.2. LinkedBlockingQueue</a></span></dt><dt><span class="section"><a href="java.util.Queue.html#id851">8.10.3. Deque 双端队列</a></span></dt><dt><span class="section"><a href="java.util.Queue.html#id852">8.10.4. 数据转换</a></span></dt><dt><span class="section"><a href="java.util.Queue.html#id853">8.10.5. PriorityBlockingQueue</a></span></dt></dl></dd><dt><span class="section"><a href="Stack.html">8.11. Stack</a></span></dt><dt><span class="section"><a href="Optional.html">8.12. Optional</a></span></dt><dd><dl><dt><span class="section"><a href="Optional.html#Optional.of()">8.12.1. of() 为非null的值创建一个Optional。</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.ofNullable()">8.12.2. ofNullable() 为指定的值创建一个Optional，如果指定的值为null，则返回一个空的Optional。
			</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.isPresent()">8.12.3. isPresent 如果值存在返回true，否则返回false。ifEmpty() null 返回 true 否则返回
				false
			</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.ifEmpty()">8.12.4. ifPresent() 如果Optional实例有值执行 lambda 表达式</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.get()">8.12.5. get() 返回值</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.orElse()">8.12.6. orElse 如果有值则将其返回，否则返回指定的其它值。</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.orElseGet()">8.12.7. orElseGet与orElse方法类似，区别在于得到的默认值从 Supplier 返回。</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.orElseThrow()">8.12.8. orElseThrow 如果有值则将其返回，否则抛出supplier接口创建的异常</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.map()">8.12.9. map() 方法用来对Optional实例的值执行一系列操作</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.flatMap()">8.12.10. flatMap()</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.filter()">8.12.11. filter() 通过传入限定条件过滤Optional值</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.stream()">8.12.12. stream()</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.or()">8.12.13. or()</a></span></dt><dt><span class="section"><a href="Optional.html#Optional.example">8.12.14. example</a></span></dt></dl></dd></dl></div>
	
	<pre class="screen">
		
Collection
 ├List
 │├LinkedList
 │├ArrayList
 │└Vector
 │　└Stack
 └Set
		
	</pre>
	<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Collection"></a>8.1. Collection 接口</h2></div></div></div>
		
		<pre class="screen">
		
Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。
　　所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后 一个构造函数允许用户复制一个Collection。
　　如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：
　　　　Iterator it = collection.iterator(); // 获得一个迭代子
　　　　while(it.hasNext()) {
　　　　　　Object obj = it.next(); // 得到下一个元素
　　　　}
由Collection接口派生的两个接口是List和Set。		
		
		</pre>
		<pre class="screen">
		
List接口
　　List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。
和下面要提到的Set不同，List允许有相同的元素。
　　除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个 ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素， 还能向前或向后遍历。
　　实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。
LinkedList类
　　LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在 LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。
　　注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：
　　　　List list = Collections.synchronizedList(new LinkedList(...));
ArrayList类
　　ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。
size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。
　　每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法 并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。
　　和LinkedList一样，ArrayList也是非同步的（unsynchronized）。
Vector类
　　Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和 ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了 Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出 ConcurrentModificationException，因此必须捕获该异常。
Stack 类
　　Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。
Set接口
　　Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。
　　很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。
　　请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。
Map接口
　　请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。		
		
		</pre>
	</div>
	

	
	
	

	
	
	
	
	
	
	
</div><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="../index.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="../index.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="java.util.List.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">部分 II. JDK Development Kit </td><td width="20%" align="center"><a accesskey="h" href="../../index.html">起始页</a></td><td width="40%" align="right" valign="top"> 8.2. List</td></tr></table></div><script xmlns="">
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-11694057-1', 'auto');
			ga('send', 'pageview');

		</script><script xmlns="" async="async">
			var _hmt = _hmt || [];
			(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
			})();
</script><script xmlns="" async="async">
			(function(){
			var bp = document.createElement('script');
			var curProtocol = window.location.protocol.split(':')[0];
			if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
			}
			else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
			}
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(bp, s);
			})();
</script></body></html>