<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2.11. DevOps实施中你可能遇到的问题</title><link rel="stylesheet" type="text/css" href="docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="index.html" title="Netkiller Architect 手札" /><link rel="up" href="多维度架构设计.html" title="第 2 章 多维度架构设计" /><link rel="prev" href="shell.html" title="2.10. Shell 高级编程" /><link rel="next" href="多维度架构设计之容器.html" title="2.12. Kubernetes &amp; Docker 实施中你会遇到的问题" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> | <a xmlns="" href="//netkiller.github.io/">简体中文</a> | <a xmlns="" href="http://netkiller.sourceforge.net/">繁体中文</a> | <a xmlns="" href="/journal/index.html">杂文</a>
		| <a xmlns="" href="https://github.com/netkiller">Github</a> | <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> | <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> | <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> | <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> | <a xmlns="" href="//www.netkiller.cn/home/donations.html">打赏(Donations)</a> | <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.11. DevOps实施中你可能遇到的问题</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="shell.html">上一页</a> </td><th width="60%" align="center">第 2 章 多维度架构设计</th><td width="20%" align="right"> <a accesskey="n" href="多维度架构设计之容器.html">下一页</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a></td><td></td><td></td><td></td><td></td></tr></table><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="devops"></a>2.11. DevOps实施中你可能遇到的问题</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="什么是DevOps?"></a>2.11.1. 什么是DevOps?</h3></div></div></div><p></p><p>首先DevOps 不是一个产品，其次说它是软件工程方法论也不准确。他是过程、方法和系统的统称，更类似笔者提出的多维度架构思想。</p><p>DevOps 这个词是由开发 Development(Dev) 和运维 Operations(Ops) 组成。它包含了三个维度，开发，测试，运维，但在实际工作中，我们也会将产品、设计、运营也纳入其中。</p><p>在 DevOps 模式下，产品，设计，开发，测试和运维团队更紧密地结合在一起，贯穿应用程序的整个生命周期。通过自动化工具替代手工操作，实现快速，高效，安全的测试，构建，部署项目。</p><div class="orderedlist"><p class="title"><strong></strong></p><ol class="orderedlist" type="1"><li class="listitem">可用的软件胜过完备的文档</li><li class="listitem">团队合作胜过需求文档</li><li class="listitem">响应变化胜过遵循流程与计划</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="为什么会诞生DevOps"></a>2.11.2. 为什么会诞生DevOps?</h3></div></div></div><p>传统软件企业以软件开发为主，开发部是最大的部门，根据项目分组，下设需求，开发，测试等岗位，并没有将运维纳入其中，这种模式已经不适合互联网企业。互联网企业通常是设置产品部，开发部，测试部，运维部，运营部，客服部等部门，但这样的组织架构带来了新的问题。</p><p>产品部关注用户体验，不考虑性能与开发合理性。开发部门的驱动力通常是“频繁交付新特性”，完成产品部提出的需求。测试部关注的是产品的BUG以及是否按照需求文档完成所有的功能。运维部更关注7*24小时无故障运行。从产品-&gt;开发-&gt;测试-&gt;运维过程看似完美，但他们目标不匹配，就在这些部门之间造成了鸿沟，从而减慢了交付业务的速度。</p><p>随着管理学的不断完善，例如工商管理，被细分为很多纵深领域，行政管理，人事管理，财务管理，营销管理，项目管理……等等。</p><p>而软件管理又被细分为：时间管理，范围管理，需求管理，质量管理，风险管理，成本管理......</p><p>由于组织架构的需要，又把人分成很多岗位，每个岗位上紧紧需要一种知识体系。企业按照自身的需要只招聘某个领域的人才。</p><p>同时我们学校也按照知识体系划分院系，本科教育程专科趋势，不重视通识教育，最终学生紧紧掌握了微观的知识。</p><p>如果说哲学是科学的科学，那么 DevOps 就是管理的管理。所以我认为 DevOps 是多维度宏观管理学。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="DevOps为什么难以普及呢"></a>2.11.3. DevOps 虽好，为什么难以普及呢？</h3></div></div></div><p>实施DevOps 第一个遇到的问题就是人才，DevOps 需要经验丰富的跨界人才。第二个问题就是没有案例可循，无法借鉴和参考。</p><p>实施DevOps需要具备管理，开发，测试，运维等等背景的人才。每个领域至少也需要三年的积累，至少需要 3+3+3+3 = 12 年工作经验，多少公司员工都比较年轻，普遍在 3~5年。
			一般员工工作10年以上，遍开始转向管理岗位，或者寻找其他出路。即使转管理岗的员工紧紧负责开发管理或者测试管理…… 不太可能10年的开发，转运维部重头开始。
		</p><p>我上面说过我们教育模式有问题，本科教育应该培养 “T” 型人才，专科教育培养 “I” 型人才，本科教育呈专科化。学校只教会学生一项技能（如Java 开发）,而没有教会学生如何学习。</p><p>在中国企业的年龄歧视 “T” 型人才流失严重。“I”人才只能掌握一项技能解决一个领域的问题，无法完成DevOps 的实施。</p><p>DevOps 不是产品，是一种管理思想，每个企业根据自身特点，制定自己的DevOps规范，所以第二个难点就是，没有案例可循，无法参考。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="软件工程的历史与进化"></a>2.11.4. 软件工程的历史与进化</h3></div></div></div><p>
			传统软件工程学出现的年代互联网还不普及，主要是单机运行的软件，或者C/S结构的软件，其特点是开发周期长，迭代慢，每半年或者一年交付一次。流程主张：
		</p><pre class="screen">
		
需求-&gt;设计-&gt;开发-&gt;测试-&gt;交付
		
		</pre><p>进入互联网时代，已B/S为主的软件，交付周期缩短到一个月，在传统软件工程做了改进，放弃了瀑布开发模式，提出了快速迭代，螺旋上升，管理上也逐步完善。出现了软件项目管理，CMM5软件开发成熟度模型。</p><p>互联网快速发展，使传统软件企业面临挑战，理论上互联网应用程序没有稳定版，新的特性源源不断加入，如果出现稳定版就意味着企业停滞。</p><div class="orderedlist"><p class="title"><strong>互联网企业面临的问题是</strong></p><ol class="orderedlist" type="1"><li class="listitem">需求频繁变更，一天一个想法，需求尚未成熟就开始投入开发软件生命周期短，以各种活动为例，很多功能是一次性的，软件生命周期可能是几周，几个月。</li><li class="listitem">频繁交付新特性，不能像传统软件一样几个月甚至几年升级一次，我们需要应对互联网快速变化，可能需要每周升级一次，甚至每天升级数次。</li><li class="listitem">随时可能回撤，随时做好回撤准备，要支持版本的任意切换</li><li class="listitem">多项目并行开发，并行开发还会产生耦合依赖，升级顺序限制，集成测试更复杂。</li></ol></div><p>随着Web 2.0 和 云计算思想的提出，软件也在发生变化，软件运行不在限于一台物理机，而是多台服务器的集群中，传统的模块或原件，被独立部署在世界各地。</p><div class="orderedlist"><p class="title"><strong>软件的开发面临前所未有的挑战：</strong></p><ol class="orderedlist" type="1"><li class="listitem">异构平台，软件不限于那种操作系统，例如Unix,Linux,As/400,windows,Mac</li><li class="listitem">语言混合开发，不在紧紧使用一种语言开发软件。每一种语言都有他所在领域的优势。</li><li class="listitem">分布式，软件再也不是只运行在 一个CPU下，软件被分成很多模块被分布式部署到多台服务上。</li></ol></div><div class="orderedlist"><p class="title"><strong>这时便出现了极限编程，敏捷开发….等等，同时诞生了新的岗位“产品”，新的思想不断提出，但是仍然无法解决面临的问题。</strong></p><ol class="orderedlist" type="1"><li class="listitem">产品部：需如雪片飞来，需求堆积如山</li><li class="listitem">开发部：版本延期，质量问题频发，疲于奔命修复 BUG，刚修复了一个， 又出现新的 Bug</li><li class="listitem">测试部：手工测试，升级后问题爆发，测试环境通过，到生产环境就出问题</li><li class="listitem">运维部：环境不统一，每次部署都是一场灾难，配置易出错，回撤时间长，</li><li class="listitem">团队现状：加班严重，效率地下，每天奔波救火</li></ol></div><p>测试环境无法重现，开发人员直接在线上修改代码，跳过测试直接将代码交给运维升级</p><p>运维事故严重影响运营和广告投放</p><p>人员流动导致代码丢失</p><div class="orderedlist"><p class="title"><strong>问题的原因在于，他们紧紧从各自部门的角度解决问题，同时 KPI 考核也不合理：</strong></p><ol class="orderedlist" type="1"><li class="listitem">产品从产品的角度解决产品遇到的问题。</li><li class="listitem">开发从开发的角度解决开发遇到的问题。</li><li class="listitem">测试从测试的角度解决测试遇到的问题。</li><li class="listitem">运维从运维的角度解决运维遇到的问题。</li></ol></div><p>实际上现在的软件已经不是当年交付后一个网管就能搞定剩下的工作。同时软件开发交付周期缩的更短，一周甚至每天升级数次，遇到突发事件要做好随时准备升级。</p><p>总结这个时期实际上是： 软件项目管理 加 ITSM (IT Service Management) IT服务管理</p><p>所以聚焦微观管理解决宏观管理问题的做法是错误的，于是诞生了 DevOps。 DevOps 是多维度宏观管理学，是管理的管理。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="为什么很多企业为什么实施DevOps以失败告终"></a>2.11.5. 为什么很多企业为什么实施 DevOps 以失败告终？</h3></div></div></div><p>很多企业实施DevOps 紧紧是软件堆砌，根本没有深入理解 DevOps 思想，仅仅是 devops 相关的软件全部安装上，然后做系统集成。使用时需要打开好几个软件，有些时项目管理软件，有些时代码管理，有些时缺陷管理，有些时持续集成……</p><div class="orderedlist"><p class="title"><strong>这时各部门一片抱怨声：</strong></p><ol class="orderedlist" type="1"><li class="listitem">管理层说：项目管理工具不好用，我要看甘特图。</li><li class="listitem">产品说：我不用那个Wiki写需求</li><li class="listitem">设计说：版本控制对于PSD这种大文件兼容不好，50M的问题每次提交很痛苦。</li><li class="listitem">开发说：我们不用 Docker，而我们也不用 maven</li><li class="listitem">测试说：怎么随意部署环境，我们还没有测试完，就清空数据了。</li><li class="listitem">运维说：生产环境我不敢用你的自动部署。</li></ol></div><p>可能用户需要打开浏览器数个窗口，频繁切换才能完成具体工作。</p><p>时不时就能听到有人在公司的QQ群、微信群、钉钉上有人喊，XXXX 环境又挂了。</p><p>改变现有的工作方式是非常痛苦的，任何不合理的流程和工作方式已经使用了多年，习惯已经根深蒂固。</p><p>实施 devops 需要各部门收集意见，对各个部门培训，改变现有的工作流程，等各部门理解了 DevOps 原理和流程后，才能实施。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="持续集成不是DevOps"></a>2.11.6. CI 持续集成不是DevOps</h3></div><div><h4 class="subtitle">Jenkins 不是 DevOps</h4></div></div></div><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。</p><p>持续集成只是 DevOps 中的一个小小的环节，并不是最主要的核心工作。</p><div class="orderedlist"><p class="title"><strong>持续集成可以解决什么问题</strong></p><ol class="orderedlist" type="1"><li class="listitem">能验证代码是否可以正常编译</li><li class="listitem">验证组件或模块是否能够集成</li><li class="listitem">验证自动化测试用例是否正常运行</li><li class="listitem">测试环境的部署</li></ol></div><div class="orderedlist"><p class="title"><strong>持续集成不能解决什么问题</strong></p><ol class="orderedlist" type="1"><li class="listitem">生产环境的发布</li><li class="listitem">部署失败后回撤</li><li class="listitem">不能/不擅长构建环境，虽然支持 Docker</li><li class="listitem">构建速度慢</li></ol></div><p>持续集成智能单向操作,例如</p><pre class="screen">
		
代码-&gt;构建-&gt;测试-&gt;部署 等等		
		
		</pre><p>持续集成中我们遇到很多问题</p><p>例如就是通过 git hook 触发 Jenkins 实现持续集成，自动构建项目。问题来了，任何提交都会触发一次 pipeline 脚本，当项目频繁提交时，第一个构建过程还未运行完毕，第二个进程便启动。导致构建排队，阻塞，同时 pipeline 可能会争夺资源（多个进程读写同一个文件），产生冲突，轻则稍等片刻，重则测试环境崩溃。</p><p>另外通过CI 持续集成部署代码也不靠谱，会出现和上面相同问题，例如第一个进程用 scp 复制 jar 包到远程主机，还未传输完成，第二个进程便做同样的操作。</p><p>还有，第一个进程重启 tomcat ，tomcat 还未停止退出，第二个请求便发出。最终导致 tomcat 崩溃。</p><p>以上的特性，你敢在生产环境上使用吗？一旦发布失败，或者需要回撤，持续集成并没有很好的解决方案。</p><p>我认为，持续集成尚不完善，测试环境玩玩可以，生产环境还是不要了。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="持续交付不是DevOps"></a>2.11.7. CD 持续交付不是 DevOps</h3></div></div></div><p>持续集成、持续交付、持续部署是一系列的软件工程实践方法，使用自动化手段达到完成软件。</p><div class="orderedlist"><p class="title"><strong>持续交付(Continuous Delivery)和持续部署(Continuous Deployment)的区别</strong></p><ol class="orderedlist" type="1"><li class="listitem">持续集成(Continuous Integration) 通过将每一次改动都提交到一个模拟产品环境中，使用严格的自动化测试，确保业务应用和服务能符合预期，最终产生构建产物。</li><li class="listitem">持续交付(Continuous Delivery) 通过持续集成产生构建物，确保让软件产品能够快速、安全的部署到产品环境中。持续交付并不是指软件每一个改动都要尽快的部署到产品环境中。它指的是任何的修改都已证明构建物可以在任何时候实施部署。</li><li class="listitem">持续部署(Continuous deployment) 是持续交付的更高阶段即生产阶段，就是将最终的产品发布到线上生产环境，给用户使用。所以当业务开发完成时，经过持续集成，持续交付后，你有信心只需要按一次按钮就能将应用快速并安全的部署到产品环境中。</li></ol></div><p>请不要再混淆持续交付与持续部署了。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="自动化部署"></a>2.11.8. 自动化部署</h3></div><div><h4 class="subtitle">我习惯将持续部署(Continuous deployment)称为自动化部署</h4></div></div></div><p>本章节重点谈自动化部署，每个人对自动化部署都有自己的理解，每个企业对自动化部署的需求也不同。</p><p>目前很多云平台开始推出一些列 DevOps 工具，体验了一下，仍然处在初级阶段，也不十分成熟。严格的说他们实现的 CD (持续交付)。</p><p>前面讲过持续集成不是 DevOps，这里我要说持续部署也不是 DevOps。自动化部署是从CI/CD中分离出来的，将部署单独提炼出来。</p><div class="orderedlist"><p class="title"><strong>自动化部署远比 CD(Continuous Delivery) 持续交付要复杂，涉及包括	</strong></p><ol class="orderedlist" type="1"><li class="listitem">网络层：网络设备管理，负载均衡切换，路由表管理</li><li class="listitem">系统层：基础设施，操作系统，软件运行环境，</li><li class="listitem">应用层：应用软件部署，配置管理，日志管理</li><li class="listitem">缓存层：缓存的刷新</li><li class="listitem">搜索层：重建全文索引</li><li class="listitem">数据层：数据库结构管理，数据库数据管理</li><li class="listitem">日志层：谁，什么时间，做了什么操作，结果怎样</li><li class="listitem">除此之外，管理上还需要提案和审批流程等等</li></ol></div><p>所以 CD （持续交付）解决不了企业的生产环境自动化部署需求，CD紧紧是CI （持续集成）运行完成后，将构建物部署到指定的运行环境中。通常CD并不提供回撤功能，所以极少由企业使用 CD 部署生产环境。</p><pre class="screen">
		
Git -&gt; 编译 -&gt; 测试 -&gt; 打包 -&gt; 构建物 -&gt; 部署 -&gt; 运行		
		
		</pre><p>CI/CD 的流水线作业只能部署单一项目，对于大型网站就无能为例</p><div class="orderedlist"><p class="title"><strong>例如很多大型网站</strong></p><ol class="orderedlist" type="1"><li class="listitem">构建过程非常复杂，不仅仅是一个项目打包， 而是需要多个模块，处理复杂的配置过程。</li><li class="listitem">一次部署多台服务器，每个服务器可能有多个实例，实例间相互依赖关系</li><li class="listitem">需要遵守严格的部署和启动顺序</li><li class="listitem">记录部署日志，文件的新增，覆盖，删除</li><li class="listitem">部署时间点</li><li class="listitem">升级不仅仅是代码，还有数据库，缓存，搜索引擎，消息队列……</li><li class="listitem">需要改变负载均衡设备节点，设置防火墙策略</li><li class="listitem">需要有完备的回撤方案</li><li class="listitem">除此之外好虚考虑增量部署和差异部署，例如部署100mb 以上的大文件，甚至GB尺寸的文件</li></ol></div><p>
			很多 DevOps 方案注重 Docker，K8s解决方案。但实际情况 Docker 并不适用于所有场景，更多是物理服务器，虚拟机，云主机，刀片服务器…
		</p><p>
			使用 Docker 的前提是，Docker必须部署在宿主主机上，在云主机中部署 Docker 意义不大。
		</p><p>
			很多企业大量使用云主机，对 Docker 并无强烈的需求。
		</p><div class="orderedlist"><p class="title"><strong>运维需要怎样的自动化部署工具</strong></p><ol class="orderedlist" type="1"><li class="listitem">项目管理：升级提案，工作流转，工作审批</li><li class="listitem">备份管理：任何生产环境部署前都需要备份，必须实现增量备份和差异备份。</li><li class="listitem">环境管理：环境部署，基础设施管理</li><li class="listitem">阶段管理：开发，测试，生产</li><li class="listitem">仓库管理：分支切换，分支保护（例如只允许合并不允许提交）</li><li class="listitem">配置管理：每个阶段拥有自己的配置</li><li class="listitem">文件过滤：排除过滤，包含过滤，内容替换，覆盖和删除（覆盖指定文件，删除指定文件）</li><li class="listitem">内容优化：Grup, Webpack 压缩js, css,html5, 图片雪碧图…..</li><li class="listitem">自动构建：编译，测试，测试报告，打包，构建物管理</li><li class="listitem">节点管理：新增节点，删除节点</li><li class="listitem">部署管理：增量部署，差异部署，md5sum 校验检查</li><li class="listitem">部署脚本：部署前脚本（停止），部署后脚本（启动）或者环境初始化，解决部署依赖</li><li class="listitem">时间线：谁，什么时间，做了部署，可以指定时间点随时回撤到指定版本。</li><li class="listitem">部署日志：谁，什么时间，做了什么操作，产生什么结果</li><li class="listitem">部署报告：自动创建部署报告（Issue或Ticker）</li></ol></div><p>持续集成与持续交付和持续部署的关系：</p><pre class="screen">
		
持续集成(CI) -&gt; 构建物 --&gt; 持续交付(CD) --&gt; 交付验收环境 （Alpha）--&gt; 验收成功
             \                                                    |                     
              \................................................../
                                         |
                                         V
                                      持续部署 ----&gt; 生产环境 (Beta/Preview/Release) ----&gt; 生产环境验收
		
		</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="收集各部门问题"></a>2.11.9. 收集各部门问题</h3></div></div></div><p>实施DevOps前需要收集各部门问题</p><div class="orderedlist"><p class="title"><strong>问题如下</strong></p><ol class="orderedlist" type="1"><li class="listitem">产品线都多少条？</li><li class="listitem">同时进行并行开发的多少条？</li><li class="listitem">怎么进行项目管理？</li><li class="listitem">产品团队的情况：怎样管理需求文档，多个产品人员怎样协作</li><li class="listitem">设计团队的情况：都使用什么设计软件，一般文件尺寸多大</li><li class="listitem">开发团队的情况：使用什么语言，什么框架，开发人员数量，采用哪种版本控制，急需解决的问题？</li><li class="listitem">测试团队的情况：测试工具，测试的方法，测试用例怎样管理，人员数量，急需解决的问题？</li><li class="listitem">运维团队的清况：服务器数量，云的使用情况，docker使用情况，运维工具，运维人员，急需解决的问题？</li><li class="listitem">目前最迫切解决的问题是什么？</li><li class="listitem">你的企业目前还面临哪些问题（非技术）？</li></ol></div><p>有了这些数据，在DevOps工具选型是，你才能判断是否符合你的需求。例如很多商用工具的 License 是按照用户数收费的。有些则按照部署节点收费。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="自运维的需求"></a>2.11.9.1. 自运维的需求</h4></div></div></div><p>例如下面是来自运维的需求</p><div class="orderedlist"><p class="title"><strong>运维团队需要什么呢</strong></p><ol class="orderedlist" type="1"><li class="listitem">合同管理</li><li class="listitem">成本管理</li><li class="listitem">续费管理</li><li class="listitem">问题管理</li><li class="listitem">突发事件管理</li><li class="listitem">环境配置</li><li class="listitem">设备管理</li><li class="listitem">配置管理</li><li class="listitem">自动化部署</li><li class="listitem">监控和报警</li><li class="listitem">备份和恢复</li></ol></div><p>上面大部需求以用Issue/Ticket 凑合，但是有几个功能例如，环境配置，自动化部署，监控/报警，备份/恢复，这些就凑合不了，实打实的硬性需求。如果不能实现这些功能，就不能称为 DevOps。</p><p>我们就先从监控说起把，你很发现很多 DevOps 的文章中，不会涉及到监控，但是这是运维的重中之重。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="收缩技术栈"></a>2.11.10. 收缩技术栈</h3></div></div></div><p>技术部门常常会陷入技术思维，恨不得将所有主流技术都使用上，却忽略了他们兼容性，以及对该技术的掌握程度。</p><p>当团队没有100%掌握某项技术是，风险是巨大的，我们常常会看到网上有这种文章《XXX踩过的坑》，无疑是拿生产环境练手，为自己的职业生涯打怪升级。</p><p>大炮打蚊子，很多需求根本无需使用复杂的技术，最终变成庞然大物。</p><p>尽量使用一种技术解决所有问题，而不是使用所有技术解决一种问题。这样技术团队学习起来不会太吃力，且团队人力资源可以共享，测试难度和运维难度都会降低。</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="模块化思维"></a>2.11.10.1. 模块化思维</h4></div></div></div><p>技术思维另一个误区就是，拆整为零，模块化。例如,用户中心，商品中心，订单中心，物流中心 ……</p><pre class="screen">
			
   用户中心 —---—- 商品中心，
     |  \       /   |
     |    \   /     |
     |      X       |
     |    /  \      |
     |  /      \    |
  订单中心 ——---- 物流中心			
			
			</pre><div class="orderedlist"><p class="title"><strong>看这个架构多么清晰</strong></p><ol class="orderedlist" type="1"><li class="listitem">用户中心： 负责用户注册，登录，找回密码</li><li class="listitem">商品中心：商品分类，商品搜索，商品列表，商品展示</li><li class="listitem">订单中心：订单报价，订单合并……</li><li class="listitem">物流中心：对接物流平台……</li></ol></div><p>技术人员的成就感飘飘然，然票票。运维根据需求将上面四个中心使用四台高配置服务器部署起来。</p><div class="orderedlist"><p class="title"><strong>市场部需求</strong></p><ol class="orderedlist" type="1"><li class="listitem">用户登录</li><li class="listitem"> 浏览商品</li><li class="listitem">下订单</li><li class="listitem">走物流</li><li class="listitem"> 用户积分+100</li></ol></div><p>平时没有什么问题，订单量一大所有问题都暴漏出来， 积分添加失败，库存数据出错，物流下单失败…… </p><div class="orderedlist"><p class="title"><strong>这种模式的问题有很多，例如</strong></p><ol class="orderedlist" type="1"><li class="listitem">运维复杂，部署复杂，配置管理复杂</li><li class="listitem">排查问题难度搞</li><li class="listitem">分离后，通过网络连接，网络存在延迟和超时等等其他不可控因素</li><li class="listitem">分布式事务处理，复杂且难以保证</li><li class="listitem">分布式锁，并发的杀手</li></ol></div><p>任何一个系统都不能简单的进行拆分，抓中拆分同样是我们教育的问题，导致思维方式产生问题。	</p><p>15年前我就意识到这种问题所在，15年后去一下电商公司面试，发现他们仍然在采用这种模式。</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="被遗忘的数据库"></a>2.11.11. 被遗忘的数据库</h3></div></div></div><p>在持续集成和持续部署中数据库常常被忽略。</p><p>实施 DevOps 对于 DBA 都不那些诉求呢？</p><div class="itemizedlist"><p class="title"><strong>这里我列举一些DBA的诉求</strong></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
				数据库备份与恢复，备份文件的安全
			</li><li class="listitem">
				数据库结构版本控制
			</li><li class="listitem">
				数据库快照
			</li><li class="listitem">
				注入扫描
			</li><li class="listitem">
				撰改报警
			</li><li class="listitem">
				SQL 审计
			</li><li class="listitem">
				数据库监控
			</li><li class="listitem">脏数据处理</li></ul></div><p>上面每一项都需要单独拿出来分析，例如监控。</p><div class="itemizedlist"><p class="title"><strong>数据库监控有可以细分为</strong></p><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
				IP 地址，包括端口，服务
			</li><li class="listitem">
				同步状态
			</li><li class="listitem">
				连接数
			</li><li class="listitem">
				缓存，命中率
			</li><li class="listitem">
				SQL语句调用统计
			</li></ul></div><p>等等</p><p>总之 DBA 需要知道，谁，什么时候，登陆了数据库服务器，做了什么操作。随时可以备份数据，恢复数据。</p><p>另外还有数据文件一致性的需求</p><p>什么是数据文件一致性？举一个例子，用户头像是一张图片，存储在用户数据表中如下</p><pre class="screen">
		
 ID | USERNAME | ICON
------------------------------
  1 | neo      | /images/neo/Avatar.jpg
		
		</pre><p>可能存在数据存在，图片找不到；或者有图片，没有数据的情况。这里只是一个例子，实际场景更复杂，例如银行票据，合同等等。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="建立中心仓库"></a>2.11.12. 建立中心仓库</h3></div></div></div><p>DevOps 需要一个核心仓库，用来管理构开发包，容器，以及建物等等。</p><div class="orderedlist"><p class="title"><strong>仓库可以分为三种类型，分别是</strong></p><ol class="orderedlist" type="1"><li class="listitem">和基础设施库</li><li class="listitem">容器仓库</li><li class="listitem">软件依赖仓库</li></ol></div><p>基础设施库包括: Yum,Apt,Snap</p><p>容器仓库包括 Docker, Helm</p><div class="orderedlist"><p class="title"><strong>软件依赖仓库包括</strong></p><ol class="orderedlist" type="1"><li class="listitem">Maven</li><li class="listitem">Gradle</li><li class="listitem">npm</li><li class="listitem">PyPI</li><li class="listitem">Ruby Gems</li><li class="listitem">PHP composer</li><li class="listitem">CPAN</li></ol></div><p>为什么需要建立这些仓库呢？</p><p>首先构建物是公司的私有资产，不可能放在开放的仓库内。其次，使用外部仓库严重影响构建速度，例如下来速度慢和一些不可控的因素，挂起，闪断等等。</p><p>通常我们将私有自建的仓库和DevOps系统放在一起，以加速构建速度。</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="缓存"></a>2.11.13. 缓存</h3></div></div></div><div class="orderedlist"><p class="title"><strong>缓存可以帮助构建程序显著提高执行速度，DevOps 涉及到的缓存包含</strong></p><ol class="orderedlist" type="1"><li class="listitem">源代码缓存</li><li class="listitem">软件开发包缓存</li><li class="listitem">构建物缓存</li></ol></div><p>另外，软件开发包缓存和构建物缓存的版本通常是递增的，所有无需考虑缓存过期的问题，但是需要考虑下载过程中出现的损害。</p><div class="orderedlist"><p class="title"><strong>常见的损坏包括</strong></p><ol class="orderedlist" type="1"><li class="listitem">源代码版本控制文件损坏，导致代码无法更新</li><li class="listitem">软件开发包依赖文件损坏，导致无法编译</li><li class="listitem">构建物损坏，导致无法部署，启动</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="安全"></a>2.11.14. 安全</h3></div></div></div><p></p><div class="orderedlist"><p class="title"><strong>DevOps 需要考虑几点安全问题</strong></p><ol class="orderedlist" type="1"><li class="listitem">隔离安全，构建过程中会将源代码下载的构建服务器，在 Pipeline 中运行脚本，即可拿到其他项目的源码，配置文件。</li><li class="listitem">环境变量安全，Pipeline 常常会用到环境变量，通常在 Pipeline 中查看所有环境变量，就可以看到其他项目的定义。</li><li class="listitem">日志安全，运行单元测试，应用产生的日志，也可能泄漏敏感数据。</li></ol></div><p>对于单一用户，这些问题没有那么严重，但是对于多用户系统或基于 SaaS 的 DevOps 的平台来说这就是大问题。
			否则会出现 A 用户可以访问 B 用户资源的问题。甚至做出一些恶意操作，下载源码，植入木马等等
		</p></div></div><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="shell.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="多维度架构设计.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="多维度架构设计之容器.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2.10. Shell 高级编程 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 2.12. Kubernetes &amp; Docker 实施中你会遇到的问题</td></tr></table></div><script xmlns="">
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-11694057-1', 'auto');
			ga('send', 'pageview');

		</script><script xmlns="" async="async">
			var _hmt = _hmt || [];
			(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
			})();
</script><script xmlns="" async="async">
			(function(){
			var bp = document.createElement('script');
			var curProtocol = window.location.protocol.split(':')[0];
			if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
			}
			else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
			}
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(bp, s);
			})();
</script></body></html>