<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>第 3 章 数据库设计</title><link rel="stylesheet" type="text/css" href="../docbook.css" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="home" href="../index.html" title="Netkiller Architect 手札" /><link rel="up" href="../index.html" title="Netkiller Architect 手札" /><link rel="prev" href="../多维度架构之压力测试.html" title="2.19. 多维度架构之压力测试" /><link rel="next" href="security.html" title="第 4 章 数据库安全" /></head><body><a xmlns="" href="//www.netkiller.cn/">Home</a> |
		<a xmlns="" href="//netkiller.github.io/">简体中文</a> |
	    <a xmlns="" href="http://netkiller.sourceforge.net/">繁体中文</a> |
	    <a xmlns="" href="/journal/index.html">杂文</a> |
	    <a xmlns="" href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> |
   	    <a xmlns="" href="https://edu.51cto.com/lecturer/1703915.html">51CTO学院</a> |
	    <a xmlns="" href="https://edu.csdn.net/lecturer/6423">CSDN程序员研修院</a> |
	    <a xmlns="" href="https://github.com/netkiller">Github</a> |
	    <a xmlns="" href="http://my.oschina.net/neochen/">OSChina 博客</a> |
	    <a xmlns="" href="https://cloud.tencent.com/developer/column/2078">腾讯云社区</a> |
	    <a xmlns="" href="https://yq.aliyun.com/u/netkiller/">阿里云栖社区</a> |
	    <a xmlns="" href="https://www.facebook.com/bg7nyt">Facebook</a> |
	    <a xmlns="" href="http://cn.linkedin.com/in/netkiller/">Linkedin</a> |
	    <a xmlns="" href="https://www.youtube.com/user/bg7nyt/videos">Youtube</a> |
	    <a xmlns="" href="//www.netkiller.cn/home/donations.html">打赏(Donations)</a> |
	    <a xmlns="" href="//www.netkiller.cn/home/about.html">About</a><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">第 3 章 数据库设计</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="../多维度架构之压力测试.html">上一页</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="security.html">下一页</a></td></tr></table><hr /></div><table xmlns=""><tr><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=watch&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;repo=netkiller.github.io&amp;type=fork&amp;count=true&amp;size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe></td><td><iframe src="//ghbtns.com/github-btn.html?user=netkiller&amp;type=follow&amp;count=true&amp;size=large" height="30" width="240" frameborder="0" scrolling="0" style="width:240px; height: 30px;" allowTransparency="true"></iframe></td><td></td><td><a href="https://zhuanlan.zhihu.com/netkiller"><img src="/images/logo/zhihu-card-default.svg" height="25" /></a></td><td valign="middle"><a href="https://zhuanlan.zhihu.com/netkiller">知乎专栏</a> ｜ <a href="https://www.zhihu.com/club/1241768772601950208">多维度架构</a></td><td></td><td></td><td></td><td></td></tr></table><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="index"></a>第 3 章 数据库设计</h1></div><div><h3 class="subtitle"><em>Database Modeling Design / RDBMS / ORDBMS / OODBMS / HDMS</em></h3></div></div></div><div class="toc"><p><strong>目录</strong></p><dl class="toc"><dt><span class="section"><a href="index.html#rdbms">3.1. 关系型数据库设计</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#data.dictionary">3.1.1. 数据字典</a></span></dt><dt><span class="section"><a href="index.html#user">3.1.2. 用户帐号表</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#signup_keyloggers">3.1.2.1. 用户注册键盘跟踪表设计</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#category">3.1.3. 分类表设计</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874461488">3.1.3.1. 树形分类表</a></span></dt><dt><span class="section"><a href="index.html#idm452874457744">3.1.3.2. 多对多分类</a></span></dt><dt><span class="section"><a href="index.html#idm452874456256">3.1.3.3. 快速检索子分类设计</a></span></dt><dt><span class="section"><a href="index.html#idm452874455152">3.1.3.4. 计算节点数量</a></span></dt><dt><span class="section"><a href="index.html#idm452874444208">3.1.3.5. Example</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#article">3.1.4. 文章表设计</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874437824">3.1.4.1. 分区表设计</a></span></dt><dt><span class="section"><a href="index.html#idm452874435696">3.1.4.2. Title性能优化</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#feedback">3.1.5. 评论表</a></span></dt><dt><span class="section"><a href="index.html#count">3.1.6. 记录点击率，阅读次数，及评分表</a></span></dt><dt><span class="section"><a href="index.html#product">3.1.7. 产品属性表</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874429312">3.1.7.1. 简单实现</a></span></dt><dt><span class="section"><a href="index.html#idm452874428080">3.1.7.2. 实现属性组管理</a></span></dt><dt><span class="section"><a href="index.html#idm452874426400">3.1.7.3. 可编辑属表</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#product.store">3.1.8. 商品库存表</a></span></dt><dt><span class="section"><a href="index.html#i18n">3.1.9. 国际化语言表</a></span></dt><dt><span class="section"><a href="index.html#workflow">3.1.10. Workflow</a></span></dt><dt><span class="section"><a href="index.html#version">3.1.11. 内容版本控制</a></span></dt><dt><span class="section"><a href="index.html#logging">3.1.12. logging 日志表的设计</a></span></dt><dt><span class="section"><a href="index.html#uuid">3.1.13. uuid 替代传统序列 id</a></span></dt><dt><span class="section"><a href="index.html#config">3.1.14. 动态配置表</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874394256">3.1.14.1. 配置表历史记录</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#captcha">3.1.15. 验证码</a></span></dt><dt><span class="section"><a href="index.html#mobile">3.1.16. 手机归属地数据库表</a></span></dt><dt><span class="section"><a href="index.html#data.check">3.1.17. 数据检查</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874376048">3.1.17.1. 身份证校验</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#current_timestamp">3.1.18. 创建与修改时间</a></span></dt><dt><span class="section"><a href="index.html#employees_online">3.1.19. 在线用户表</a></span></dt><dt><span class="section"><a href="index.html#html2text">3.1.20. HTML TO Text</a></span></dt><dt><span class="section"><a href="index.html#sns">3.1.21. SNS 数据库设计</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874356240">3.1.21.1. people 表</a></span></dt><dt><span class="section"><a href="index.html#idm452874353776">3.1.21.2. firend 表</a></span></dt><dt><span class="section"><a href="index.html#idm452874352016">3.1.21.3. 演示</a></span></dt><dt><span class="section"><a href="index.html#idm452874346976">3.1.21.4. network 表</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#db.cache">3.1.22. 数据库与缓存</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#what">3.1.22.1. 什么是数据库缓存？</a></span></dt><dt><span class="section"><a href="index.html#why">3.1.22.2. 为什么缓存数据呢？</a></span></dt><dt><span class="section"><a href="index.html#when">3.1.22.3. 什么时候使用数据库缓存</a></span></dt><dt><span class="section"><a href="index.html#where">3.1.22.4. 涉及缓存的地方有哪些</a></span></dt><dt><span class="section"><a href="index.html#who">3.1.22.5. 谁来控制数据库缓存</a></span></dt><dt><span class="section"><a href="index.html#how">3.1.22.6. 怎么控制数据库缓存</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874321184">3.1.22.6.1. SQL_CACHE 缓存</a></span></dt><dt><span class="section"><a href="index.html#idm452874317264">3.1.22.6.2. 禁止缓存 SQL_NO_CACHE</a></span></dt><dt><span class="section"><a href="index.html#idm452874312096">3.1.22.6.3. 关闭缓存 set session query_cache_type=off</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="index.html#ordbms">3.1.23. PostgreSQL 所特有数据库设计</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#city">3.1.23.1. 国家地区表的设计</a></span></dt><dt><span class="section"><a href="index.html#discuss">3.1.23.2. 话题讨论表的设计</a></span></dt><dt><span class="section"><a href="index.html#account">3.1.23.3. 账户表/余额表/消费储蓄表</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#db.parallel">3.1.24. 数据库并行访问控制</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#show">3.1.24.1. 防止并行显示</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#sharding">3.1.25. Sharding</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sharding.horizontal">3.1.25.1. horizontal</a></span></dt><dt><span class="section"><a href="index.html#sharding.vertical">3.1.25.2. vertical</a></span></dt><dt><span class="section"><a href="index.html#sharding.news">3.1.25.3. 新闻数据库分表案例</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#db.bigdata">3.1.26. MySQL 大数据操作注意事项</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm452874250000">3.1.26.1. 关于 delete</a></span></dt><dt><span class="section"><a href="index.html#idm452874248192">3.1.26.2. 关于 update</a></span></dt><dt><span class="section"><a href="index.html#idm452874245888">3.1.26.3. 关于创建索引</a></span></dt><dt><span class="section"><a href="index.html#idm452874242800">3.1.26.4. 关于 OPTIMIZE</a></span></dt><dt><span class="section"><a href="index.html#idm452874240976">3.1.26.5. 关于切换引擎</a></span></dt><dt><span class="section"><a href="index.html#idm452874236768">3.1.26.6. 确保SELECT不被受阻</a></span></dt><dt><span class="section"><a href="index.html#idm452874236512">3.1.26.7. 记录操作者</a></span></dt></dl></dd></dl></dd></dl></div>
	
	
	<p>下面数据库设计实例中，大部分使用MySQL,PostgreSQL为例,少部分以Oracle为例。</p>
	
	

<div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="rdbms"></a>3.1. 关系型数据库设计</h2></div><div><h3 class="subtitle">MySQL 数据库设计案例</h3></div></div></div>
	
	
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="data.dictionary"></a>3.1.1. 数据字典</h3></div></div></div>
		
		<p>我不建议使用传统的《数据字典》，我的做法是E-R图加数据库注释</p>
		<p>注释伴随表，视图，触发器，过程等等，便于维护</p>
	</div>	
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="user"></a>3.1.2. 用户帐号表</h3></div></div></div>
		
		<p>用户帐号或通行证系统设计，下面以我的数库为例讲解。</p>
		<p>我一般使用两个表 passport，profile 完成网站会员系统。</p>
		<p>首先说说passport表，你也要以使用user或member等等命名，这个表设计尽可能地简单，不要使用过多字段。仅保存登录所必须用到的字段，如user,password,nickname,email... 登录帐号和密码做复合索引。</p>
		<p>然后是profile表，这个表与passport是1:1关系，保存用户详细信息</p>
		<p>这样设计可以保证海量用户登录时的速度。</p>
		<pre class="programlisting">
		
+----------+
| user     |
|----------|
|id        | &lt;---+
|username  |     |
|password  |     |
|nickname  |     |
|status    |     |
+----------+     |
                1:1
+----------+     |
| profile  |     |
|----------|     |
|user_id   | o---+
|name      |
|sex       |
|address   |
|telphone  |
|status    |
+----------+
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="signup_keyloggers"></a>3.1.2.1. 用户注册键盘跟踪表设计</h4></div></div></div>
			
			<p>该表的功能是，防止用户注册过程中流逝，记录已经填写的数据。</p>
			<pre class="programlisting">
			
CREATE TABLE `signup_keyloggers` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '唯一ID',
	`cookie` VARCHAR(32) NOT NULL COMMENT 'cookie id',
	`type` ENUM('baidu','google') NOT NULL COMMENT '推广账号类型',
	`field` ENUM('Name','Mobile','Email') NOT NULL COMMENT '字段名',
	`value` VARCHAR(50) NOT NULL COMMENT '值',
	`status` ENUM('New','Sent','Ignored','Called','Processed') NOT NULL DEFAULT 'New' COMMENT '状态',
	`operator` VARCHAR(10) NOT NULL COMMENT '操作人',
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
	`mtime` TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '状态修改时间',
	PRIMARY KEY (`id`),
	UNIQUE INDEX `unique_index` (`type`, `cookie`, `field`, `value`)
)
COMMENT='用户注册键盘记录器'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
			</pre>
			<p>当用户注册成功会根据cookie id 删除该表中的数据。</p>
			<p>当数据被记录后，客服就可以对客户回访，并修改状态status，忽略 Ignored，邮件发送Sent， 电话回访Called等等</p>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="category"></a>3.1.3. 分类表设计</h3></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874461488"></a>3.1.3.1. 树形分类表</h4></div></div></div>
			
			<pre class="screen">
			
 +-----------+
 | category  |
 |-----------|
 |id         | &lt;---+
 |title      |     |
 |description|    1:n
 |status     |     |
 |parent_id  | o---+
 +-----------+
			
			</pre>
		<pre class="programlisting">
		
CREATE TABLE `category` (
	`id` SMALLINT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(10) NOT NULL,
	`description` VARCHAR(255) NULL,
	`status` ENUM('enable','desable') NOT NULL DEFAULT 'enable',
	`parent_id` SMALLINT(10) UNSIGNED NOT NULL DEFAULT '0',
	PRIMARY KEY (`id`),
	CONSTRAINT `FK1` FOREIGN KEY (`parent_id`) REFERENCES `category` (`id`)
)
COMMENT='goods category'
ENGINE=InnoDB
ROW_FORMAT=DEFAULT
		
		</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874457744"></a>3.1.3.2. 多对多分类</h4></div></div></div>
			
		<p>多对多分类,主要用于满足，一个产品/文章属于多个分类的需求。</p>
		<pre class="programlisting">
		
      +------------+
      | category   |
      |------------|
 +--&gt; |id          | &lt;---+
 |    |title       |     |     +----------------------+
1:n   |description |    1:n    | categroy_has_product |
 |    |status      |     |     +----------------------+
 +--o |parent_id   |     |     | id                   |
      +------------+     +---o | category_id          |
                         +---o | product_id           |
      +------------+     |     +----------------------+
      | product    |    1:n
      +------------+     |
      |id          | &lt;---+
      |price       |
      |quantity    |
      |...         |
      |status      |
      +------------+
		
		</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874456256"></a>3.1.3.3. 快速检索子分类设计</h4></div></div></div>
			
			<p>上面我刚刚讲过怎样实现“不限子树的分类树”，我们可以实现不限层次的无线分类表。</p>
			<pre class="screen">
			
 +-----------+
 | category  |
 |-----------|
 |id         | &lt;---+
 |title      |     |
 |description|    1:n
 |status     |     |
 |parent_id  | o---+
 +-----------+
			
			</pre>
			<p>
				问题出来了，当我需要读取一个分类（任意分类）下的所有子分类，怎样实现，很多人会说用“递归”。
				当然“递归”可是现实我们的需求，在几百个分类的项目中，使用递归也不是不可以的，但是当数量非常庞大时怎么办？
			</p>
			<p>当然有更好的解决方案，请看下面</p>
			<pre class="screen">
			
 +-----------+
 | category  |
 |-----------|
 |id         | &lt;---+
 |title      |     |
 |description|    1:n
 |status     |     |
 |parent_id  | o---+
 |path       |
 +-----------+
			
			</pre>
			<pre class="screen">
			
+-------------------------------------------------------------------------+
| category                                                                |
+----+-----------+-----------------------+--------+-----------+-----------+
| id | name      | description           | status | parent_id | path      |
+----+-----------+-----------------------+--------+-----------+-----------+
|  1 | 中国    | 中华人民共和家                                    | Y      |      NULL | 1/        |
|  4 | 广东省 | 广东省                                                      | Y      |         1 | 1/4       |
|  5 | 深圳市 | NULL                      | Y      |         4 | 1/4/5     |
|  6 | 宝安区 | NULL                      | Y      |         5 | 1/4/5/6   |
|  7 | 龙华镇 | NULL                      | Y      |         6 | 1/4/5/6/7 |
+----+-----------+-----------------------+--------+-----------+-----------+
			
			</pre>
			<pre class="programlisting">
			
CREATE TABLE `category` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '分类ID',
	`name` VARCHAR(50) NOT NULL COMMENT '分类名称',
	`description` VARCHAR(200) NULL DEFAULT NULL COMMENT '分类描述',
	`status` ENUM('Y','N') NOT NULL DEFAULT 'Y' COMMENT '分类状态有继承性',
	`parent_id` INT(10) NULL DEFAULT '1' COMMENT '分类父ID',
	`path` VARCHAR(255) NOT NULL COMMENT '分类递归路径索引',
	INDEX `PK` (`id`),
	INDEX `relation` (`id`, `parent_id`),
	INDEX `FK_category_category` (`parent_id`),
	INDEX `path` (`path`)
)
COMMENT='分类表'
ENGINE=InnoDB
ROW_FORMAT=DEFAULT
AUTO_INCREMENT=0

insert into category(`name`,`description`,`status`,`parent_id`,`path`) values('中国','中华人民共和家','Y',null,'1/')
			
			</pre>
			<pre class="programlisting">
			
ALTER TABLE `category`
	ADD CONSTRAINT `FK_category_category` FOREIGN KEY (`parent_id`) REFERENCES `category` (`id`)
			
			</pre>
			<p>抽取广东子树</p>
			<pre class="programlisting">
			
select * from category where path like '1/4%';
			
			</pre>
			<pre class="screen">
			
mysql&gt; select * from category where path like '1/4%';
+----+-----------+-------------+--------+-----------+-----------+
| id | name      | description | status | parent_id | path      |
+----+-----------+-------------+--------+-----------+-----------+
|  4 | 广东省 | 广东省   | Y      |         1 | 1/4       |
|  5 | 深圳市 | NULL        | Y      |         4 | 1/4/5     |
|  6 | 宝安区 | NULL        | Y      |         5 | 1/4/5/6   |
|  7 | 龙华镇 | NULL        | Y      |         6 | 1/4/5/6/7 |
+----+-----------+-------------+--------+-----------+-----------+
4 rows in set (0.00 sec)
			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874455152"></a>3.1.3.4. 计算节点数量</h4></div></div></div>
			
			<pre class="screen">
			
DROP TABLE IF EXISTS `test`;
CREATE TABLE IF NOT EXISTS `test` (
  `id` int(11) DEFAULT NULL,
  `pid` int(11) DEFAULT NULL,
  `name` char(50) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

INSERT INTO `test` (`id`, `pid`, `name`) VALUES
	(1, 0, 'A'),
	(2, 1, 'B'),
	(3, 1, 'C'),
	(4, 0, 'D'),
	(5, 0, 'E'),
	(6, 5, 'F');

select (select t2.name from test t2 where t2.id=t1.pid) as name, count(pid) as sum from test t1 where t1.pid &lt;&gt; 0 group by t1.pid;
			
			</pre>
			<p>统计所有节点包括数量为零的</p>
			<pre class="screen">
select t1.name, (select count(t2.name) from test t2 where t2.pid=t1.id) as sum from test t1
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874444208"></a>3.1.3.5. Example</h4></div></div></div>
			
			<div class="example"><a id="idm452874443488"></a><p class="title"><strong>例 3.1. identity_card 身份证归属地表</strong></p><div class="example-contents">
				
				<pre class="programlisting">
CREATE TABLE `identity_card` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '唯一主键',
	`pid` INT(10) UNSIGNED NOT NULL DEFAULT '0' COMMENT '父ID',
	`path` VARCHAR(50) NOT NULL COMMENT '路径',
	`number` VARCHAR(18) NOT NULL COMMENT '身份证号码段',
	`zone` VARCHAR(50) NOT NULL COMMENT '行政区域',
	`status` ENUM('Y','N') NOT NULL DEFAULT 'N' COMMENT '状态',
	`modified` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建与修改时间',
	PRIMARY KEY (`id`),
	INDEX `FK_identity_card_identity_card` (`pid`),
	INDEX `path` (`path`),
	INDEX `number` (`number`),
	CONSTRAINT `FK_identity_card_identity_card` FOREIGN KEY (`pid`) REFERENCES `identity_card` (`id`) ON UPDATE CASCADE ON DELETE CASCADE
)
COMMENT='identity card number'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
				</pre>
				<pre class="screen">
"id"	"pid"	"path"	"number"	"zone"	"status"	"modified"
"1012"	"1"	"1.1012"	"330000"	"浙江省"	"Y"	"2012-05-16 17:18:14"
"1041"	"1012"	"1.1012.1041"	"330300"	"温州市"	"Y"	"2012-05-16 17:44:18"
"1052"	"1041"	"1.1012.1041.1052"	"330381"	"瑞安市"	"Y"	"2012-05-16 17:44:25"
"1367"	"1"	"1.1367"	"360000"	"江西省"	"Y"	"2012-05-16 16:57:23"
"1451"	"1367"	"1.1367.1451"	"360900"	"宜春市"	"Y"	"2012-05-16 17:44:58"
"1990"	"1"	"1.1990"	"430000"	"湖南省"	"Y"	"2012-05-16 16:50:50"
"1991"	"1990"	"1.1990.1991"	"430100"	"长沙市"	"Y"	"2012-05-16 16:50:54"
"2124"	"1990"	"1.1990.2124"	"431300"	"娄底市"	"Y"	"2012-05-16 16:54:45"
				</pre>
			</div></div><br class="example-break" />
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="article"></a>3.1.4. 文章表设计</h3></div></div></div>
		
		<p>看具体情况，拆分表，可按“日”，“月”，“年”等等</p>
		<pre class="programlisting">
		
      +-----------+
      | category  |
      |-----------|
  +--&gt;|id         | &lt;---+
  |   |title      |     |
  |   |description|    1:n
  |   |status     |     |
  |   |parent_id  | o---+
  |   +-----------+
  |
 1:n
  |
  |   +-----------------+            +------------------+
  |   | article_2008_01 |            | feedback_2008_01 |
  |   |-----------------|            |------------------|
  |   |id               |&lt;--1:n--+   |id                |
  |   |title            |        |   |title             |
  |   |content          |        |   |content           |
  |   |datetime         |        |   |datetime          |
  |   |status           |        |   |status            |
  +--o|category_id      |        +--o|news_id           |
  +--o|user_id          |        +--&gt;|user_id           |
  |   +-----------------+        |   +------------------+
  |                              |
 1:n  +----------+     +---1:n---+
  |   | user     |     |
  |   |----------|     |
  +--&gt;|id        | &lt;---+
      |user      |
      |passwd    |
      |nickname  |
      |status    |
      +----------+
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874437824"></a>3.1.4.1. 分区表设计</h4></div></div></div>
			
			<p>分区表可以通过表空间，等等技术实现，优点是解决了Union查询问题，保证了数据的一致性。</p>
		<pre class="programlisting">
		
      +-----------+
      | category  |
      |-----------|
  +--&gt;|id         | &lt;---+
  |   |title      |     |
  |   |description|    1:n
  |   |status     |     |
  |   |parent_id  | o---+
  |   +-----------+
  |
 1:n
  |
  |   +-----------------+            +-----------------+
  |   | article         |            | feedback        |
  |   |-----------------|            |-----------------|
  |   |id               |&lt;--1:n--+   |id               |
  |   |title            |        |   |title            |
  |   |content          |        |   |content          |
  |   |datetime         |        |   |datetime         |
  |   |status           |        |   |status           |
  +--o|category_id      |        +--o|news_id          |
  +--o|user_id          |        +--&gt;|user_id          |
  |   +-----------------+        |   +-----------------+
  |   | 2007,2008,2009  |        |   | 2007,2008,2009  |
  |   +-----------------+        |   +-----------------+
  |                              |
 1:n  +----------+     +---1:n---+
  |   | user     |     |
  |   |----------|     |
  +--&gt;|id        | &lt;---+
      |user      |
      |passwd    |
      |nickname  |
      |status    |
      +----------+
		
		</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874435696"></a>3.1.4.2. Title性能优化</h4></div></div></div>
			
			<p>显示title前20个汉字并在后尾添加省略号。</p>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="feedback"></a>3.1.5. 评论表</h3></div></div></div>
		
		<pre class="programlisting">
		
+----------+
| user     |
|----------|
|id        | &lt;---+
|user      |     |
|passwd    |     |
|nickname  |     |
|status    |     |
+----------+     |
                1:n
+-----------+    |      +-----------+
| feedback  |    |      | news      |
|-----------|    |      |-----------|
|id         |    |  +--&gt;|id         |
|title      |    |  |   |title      |
|content    |    |  |   |content    |
|datetime   |    | 1:n  |datetime   |
|status     |    |  |   |status     |
|user_id    |o---+  |   |user_id    |
|news_id    |o------+   +-----------+
+-----------+
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="count"></a>3.1.6. 记录点击率，阅读次数，及评分表</h3></div></div></div>
		
		<pre class="programlisting">
		
+--------------+             +--------------+
| article      |             | article_rank |
|--------------|             |--------------|
|id            | &lt;---1:1---o |article_id    |
|title         |             |click         |
|content       |             |read          |
|datetime      |             |score         |
|status        |             |...           |
|category_id   |             |...           |
|user_id       |             |...           |
+--------------+             +--------------+
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="product"></a>3.1.7. 产品属性表</h3></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874429312"></a>3.1.7.1. 简单实现</h4></div></div></div>
			
		<pre class="programlisting">
		
+------------+           +--------------------------+           +-----------------------+
| product    |           | product_attribute        |           |product_attribute_key  |
+------------+           +--------------------------+           +-----------------------+
|id          | &lt;--1:1--o |product_id                |     +---&gt; |id                     |
|price       |           |product_attribute_key_id  | o---+     |name                   |
|quantity    |           |product_attribute_value_id| o---+     +-----------------------+
|...         |           +--------------------------+     |     +-----------------------+
|category_id |                                           1:n    |product_attribute_value|
+------------+                                            |     +-----------------------+
                                                          +---&gt; |id                     |
                                                                |name                   |
                                                                +-----------------------+
		
		</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874428080"></a>3.1.7.2. 实现属性组管理</h4></div></div></div>
			
		<p>product attribute group</p>
		<pre class="programlisting">
		
+------------+           +--------------------------+           +--------------------------+           +-----------------------+
| category   |           | product_attribute_group  |           | product_attribute        |           |product_attribute_key  |
+------------+           +--------------------------+           +--------------------------+           +-----------------------+
|id          |     +---&gt; |id                        | &lt;--1:n--o |product_attribute_group_id|     +---&gt; |id                     |
|title       |     |     |name                      |           |product_attribute_key_id  | o---+     |name                   |
|description |    1:1    |status                    |           |product_attribute_value_id| o---+     +-----------------------+
|status      |     |     +--------------------------+           +--------------------------+     |     +-----------------------+
|parent_id   |     |                                                                            1:n    |product_attribute_value|
|default_pag | o---+                                                                             |     +-----------------------+
+------------+                                                                                   +---&gt; |id                     |
                                                                                                       |name                   |
                                                                                                       +-----------------------+
		
		</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874426400"></a>3.1.7.3. 可编辑属表</h4></div></div></div>
			
		    <p>product attribute group</p>
		    <pre class="programlisting">
		    
    +------------+           +------------------+           +--------------------------+           +---------------------------------+
    | category   |           | attribute_group  |           | group_has_attribute      |           |attribute_key                    |
    +------------+           +------------------+           +--------------------------+           +---------------------------------+
 +-&gt;|id          |     +--&gt;  |id                | &lt;--1:n--o |attribute_group_id        |     +-+-&gt; |id                               |
 |  |title       |     |     |name              |           |attribute_key_id          | o---+ |   |name                             |
 |  |description |    1:1    |status            |           |                          |       |   |type enum('Bool','List','Input') |
 |  |status      |     |     +------------------+           +--------------------------+       |   |default array()                  |
 |  |parent_id   |     |                                                                       |   +---------------------------------+
 |  |default_pag | o---+                                                                       |
 |  +------------+                                                                             |
1:n                                                                                            |
 |  +-------------+             +--------------------------+                                   |
 |  | product     |             | product_attribute        |                                   |
 |  +-------------+             +--------------------------+                                   |
 |  |id           |         +-&gt; |product_id                |                                   |
 |  |price        |         |   |attribute_key_id          | o---------------1:n---------------+
 |  |quantity     |         |   |attribute_value           |
 |  |...          |         |   +--------------------------+
 +-o|category_id  |         |
    |attr_group_id| &lt;--1:n--o
    +-------------+
		    
		    </pre>
		    <pre class="screen">
+--------------------------------------------------+
| product_attribute_key                            |
+--------------------------------------------------+
| 1 | color | list | red,green,blue                |
| 2 | sex   | bool | Female,Male                   |
| 3 | qty   | input| ''                            |
+--------------------------------------------------+
		    </pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="product.store"></a>3.1.8. 商品库存表</h3></div></div></div>
		
		<pre class="screen">
		
+------------+              +----------------+               +------------------+
| product    |              | product_store  |               | user_order       |
+------------+              +----------------+               +------------------+
|id          | &lt;--+         |id              | &lt;---+         |id                |
|price       |    +--1:1--o |product_id      |     |         |user_id           |
|quantity    |              |sn              |     +--1:n--o |product_store_id  |
|...         |              |status          |               |                  |
|category_id |              +----------------+               +------------------+
+------------+
		
		</pre>
		<p>product 是产品表总表，product_store每个产品一条记录，同时将sn编号对应到物理产品，这时记录库存需要</p>
		<pre class="programlisting">
select count(id) from product_store where product_id='xxxxx' and status = 'sell'
		</pre>
		<p>商品销售</p>
		<pre class="programlisting">
begin;
select id from product_store where status = 'sale' and product_id='xxxxx' for update;
insert into user_order(user_id,product_store_id) values('xxxxxx','xxxxx');
update product_store set status = 'sold' where status = 'sale' and product_id='xxxxx';
commit;
		</pre>
		<p>售出的商品与用户的订单项一一对应的。</p>
		<p>注意上面，这里使用了排它锁与事务处理，防止一个商品卖给两个人。</p>
		<p>根据上面的思路我们可以将商品属性与product_store表进行一对一匹配，这样每个商品都有它自己的商品属性，甚至价格也可以移到product_store表中，例如不同颜色售价不同。</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="i18n"></a>3.1.9. 国际化语言表</h3></div></div></div>
		
		<p></p>
		<pre class="programlisting">
		
      +-----------+             +---------------+
      | category  |    .---+    | category_lang |
      |-----------|   /    |    +---------------+
  +--&gt;|id         | &lt;---+  +--o |category_id    |
  |   |title      |     |       |language_id    | o---+
  |   |description|    1:n      |name           |     |      +-------------+
  |   |status     |     |       +---------------+     .      | language    |
  |   |parent_id  | o---+                              \     +-------------+
  |   +-----------+                                     &gt;--&gt; |id           |
 1:n                                                   /     |lang         |
  |   +------------+                                  '      |status       |
  |   | product    |                                  |      +-------------+
  |   +------------+           +--------------+       |
  |   |id          | &lt;---+     | product_lang |       |
  |   |price       |     |     +--------------+       |
  |   |quantity    |     +---o |product_id    |       |
  |   |...         |           |language_id   | o-----+
  +-o |category_id |           |name          |
      +------------+           +--------------+
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="workflow"></a>3.1.10. Workflow</h3></div></div></div>
		
		<pre class="programlisting">
		

   +------------+     +---------------+     +-----------+
   | user       |     | role_has_user |     | role      |
   +------------+     +---------------+     +-----------+
   |id          |o-+  |id             |  +-&gt;|id         |&lt;-+
   |node_id     |  +-&gt;|user_id        |  |  |name       |  |
   |up_id       |     |role_id        |o-+  |description|  |
   +------------+	  +---------------+     +-----------+  |
		                                                   |
   +----------------+     +------------+                   |
   | workflow       |     | job        |                   |
   +----------------+     +------------+                   |
+-&gt;|id              |  +-&gt;|id          |                   |
|  |job_id          |o-+  |name        |                   |
+-o|up_id           |     |role_id     |o------------------+
   |                |     |description |
   +----------------+	  +------------+

		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="version"></a>3.1.11. 内容版本控制</h3></div></div></div>
		
		<p>主表</p>
		<pre class="programlisting">
CREATE TABLE `article` (
	`article_id` MEDIUMINT(8) UNSIGNED NOT NULL AUTO_INCREMENT,
	`cat_id` SMALLINT(5) NOT NULL DEFAULT '0',
	`title` VARCHAR(150) NOT NULL DEFAULT '',
	`content` LONGTEXT NOT NULL,
	`author` VARCHAR(30) NOT NULL DEFAULT '',
	`keywords` VARCHAR(255) NOT NULL DEFAULT '',
	PRIMARY KEY (`article_id`),
	INDEX `cat_id` (`cat_id`)
)
ENGINE=MyISAM
ROW_FORMAT=DEFAULT
AUTO_INCREMENT=1
		</pre>
		<p>本版控制表，用于记录每次变动</p>
		<pre class="programlisting">
CREATE TABLE `article_history` (
	`id` MEDIUMINT(8) UNSIGNED NOT NULL AUTO_INCREMENT,
	`article_id` MEDIUMINT(8) UNSIGNED NOT NULL,
	`cat_id` SMALLINT(5) NOT NULL DEFAULT '0',
	`title` VARCHAR(150) NOT NULL DEFAULT '',
	`content` LONGTEXT NOT NULL,
	`author` VARCHAR(30) NOT NULL DEFAULT '',
	`keywords` VARCHAR(255) NOT NULL DEFAULT '',
	PRIMARY KEY (`id`),
	INDEX `article_id` (`article_id`)
)
ENGINE=MyISAM
ROW_FORMAT=DEFAULT
AUTO_INCREMENT=1
		</pre>
		<p>版本控制触发器</p>
		<pre class="programlisting">
DROP TRIGGER article_history;

DELIMITER //
CREATE TRIGGER article_history BEFORE update ON article FOR EACH ROW
BEGIN
	INSERT INTO article_history SELECT * FROM article WHERE article_id = OLD.article_id;
END; //
DELIMITER;
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="logging"></a>3.1.12. logging 日志表的设计</h3></div></div></div>
		
		<pre class="screen">
CREATE TABLE `logging` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`tag` ENUM('unknow','www','user','admin') NOT NULL DEFAULT 'unknow' COMMENT '日志标签',
	`time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '产生时间',
	`facility` ENUM('bank','unionpay','sms','email') NOT NULL COMMENT '类别',
	`priority` ENUM('info','warning','error','critical','exception','debug') NOT NULL COMMENT '级别',
	`message` VARCHAR(512) NOT NULL COMMENT '内容',
	PRIMARY KEY (`id`)
)
COMMENT='日志表'
COLLATE='utf8_general_ci'
ENGINE=InnoDB
AUTO_INCREMENT=2;
		</pre>
		<p>分区日志表</p>
		<pre class="programlisting">
		
delimiter $$

CREATE TABLE `logging` (
  `tag` enum('unknow','login','info','admin','cron','manual') NOT NULL DEFAULT 'unknow' COMMENT '日志标签',
  `asctime` datetime NOT NULL COMMENT '产生时间',
  `facility` enum('account','bank','unionpay','sms','email','unknow') NOT NULL DEFAULT 'unknow' COMMENT '类别',
  `priority` enum('info','warning','error','critical','exception','debug') NOT NULL DEFAULT 'debug' COMMENT '级别',
  `message` varchar(512) NOT NULL COMMENT '内容',
  `operator` varchar(50) NOT NULL DEFAULT 'computer' COMMENT '操作者'
) ENGINE=InnoDB DEFAULT CHARSET=utf8
/*!50100 PARTITION BY RANGE (YEAR(asctime))
SUBPARTITION BY HASH (MONTH(asctime))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (2000) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */$$
		
		</pre>
		<p>分表+分区，每年分表一次，每个分区中保存一个月的数据</p>
		<pre class="programlisting">
delimiter $$

CREATE TABLE `logging_2013` (
  `tag` enum('unknow','login','info','admin','cron','manual') NOT NULL DEFAULT 'unknow' COMMENT '日志标签',
  `asctime` datetime NOT NULL COMMENT '产生时间',
  `facility` enum('account','bank','unionpay','sms','email','unknow') NOT NULL DEFAULT 'unknow' COMMENT '类别',
  `priority` enum('info','warning','error','critical','exception','debug') NOT NULL DEFAULT 'debug' COMMENT '级别',
  `message` varchar(512) NOT NULL COMMENT '内容',
  `operator` varchar(50) NOT NULL DEFAULT 'computer' COMMENT '操作者'
) ENGINE=InnoDB DEFAULT CHARSET=utf8
/*!50100 PARTITION BY LIST (MONTH(asctime))
SUBPARTITION BY KEY (facility)
(PARTITION part0 VALUES IN (1) ENGINE = InnoDB,
 PARTITION part1 VALUES IN (2) ENGINE = InnoDB,
 PARTITION part2 VALUES IN (3) ENGINE = InnoDB,
 PARTITION part3 VALUES IN (4) ENGINE = InnoDB,
 PARTITION part4 VALUES IN (5) ENGINE = InnoDB,
 PARTITION part5 VALUES IN (6) ENGINE = InnoDB,
 PARTITION part6 VALUES IN (7) ENGINE = InnoDB,
 PARTITION part7 VALUES IN (8) ENGINE = InnoDB,
 PARTITION part8 VALUES IN (9) ENGINE = InnoDB,
 PARTITION part9 VALUES IN (10) ENGINE = InnoDB,
 PARTITION part10 VALUES IN (11) ENGINE = InnoDB,
 PARTITION part11 VALUES IN (12) ENGINE = InnoDB) */$$
		</pre>
		<p>命名分区</p>
		<pre class="programlisting">
delimiter $$

CREATE TABLE `logging_2012` (
  `tag` enum('unknow','login','info','admin','cron','manual') NOT NULL DEFAULT 'unknow' COMMENT '日志标签',
  `asctime` datetime NOT NULL COMMENT '产生时间',
  `facility` enum('account','bank','unionpay','sms','email','unknow') NOT NULL DEFAULT 'unknow' COMMENT '类别',
  `priority` enum('info','warning','error','critical','exception','debug') NOT NULL DEFAULT 'debug' COMMENT '级别',
  `message` varchar(512) NOT NULL COMMENT '内容',
  `operator` varchar(50) NOT NULL DEFAULT 'computer' COMMENT '操作者'
) ENGINE=InnoDB DEFAULT CHARSET=utf8
/*!50100 PARTITION BY LIST (MONTH(asctime))
SUBPARTITION BY KEY (facility)
(PARTITION January VALUES IN (1) ENGINE = InnoDB,
 PARTITION February VALUES IN (2) ENGINE = InnoDB,
 PARTITION March VALUES IN (3) ENGINE = InnoDB,
 PARTITION April VALUES IN (4) ENGINE = InnoDB,
 PARTITION May VALUES IN (5) ENGINE = InnoDB,
 PARTITION June VALUES IN (6) ENGINE = InnoDB,
 PARTITION July VALUES IN (7) ENGINE = InnoDB,
 PARTITION August VALUES IN (8) ENGINE = InnoDB,
 PARTITION September VALUES IN (9) ENGINE = InnoDB,
 PARTITION October VALUES IN (10) ENGINE = InnoDB,
 PARTITION November VALUES IN (11) ENGINE = InnoDB,
 PARTITION December VALUES IN (12) ENGINE = InnoDB) */$$
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="uuid"></a>3.1.13. uuid 替代传统序列 id</h3></div></div></div>
		
		<pre class="screen">
		
DROP TABLE IF EXISTS `uuid_test`;
CREATE TABLE IF NOT EXISTS `uuid_test` (
  `uuid` varchar(36) NOT NULL,
  `name` varchar(20) NOT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='uuid 测试';
		
		</pre>
		<p>插入触发器</p>
		<pre class="screen">
		
DROP TRIGGER IF EXISTS `uuid_test_insert`;
SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='';
DELIMITER //
CREATE TRIGGER `uuid_test_insert` BEFORE INSERT ON `uuid_test` FOR EACH ROW BEGIN
	IF new.uuid is null or new.uuid = '' or length(new.uuid) != 36 THEN
		set new.uuid=uuid();
	END IF;
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;
		
		</pre>
		<p>ID放撰改触发器</p>
		<pre class="screen">
		
DROP TRIGGER IF EXISTS `uuid_test_update`;
SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='';
DELIMITER //
CREATE TRIGGER `uuid_test_update` BEFORE UPDATE ON `uuid_test` FOR EACH ROW BEGIN
	set new.uuid = old.uuid;
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="config"></a>3.1.14. 动态配置表</h3></div></div></div>
		
		<p>很多时候我们需要使用数据库存储配置项，由于各种原因我们无法使用配置文件来完成，例如在一个有很多节点集群环境中使用文件配置文件时非常不方便。</p>
		<pre class="screen">
		
DROP TABLE IF EXISTS `config`;
CREATE TABLE IF NOT EXISTS `config` (
  `key` varchar(50) NOT NULL,
  `value` varchar(50) NOT NULL,
  `operator` varchar(50) NOT NULL DEFAULT 'dba',
  `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='网站动态配置文件';


INSERT INTO `config` (`key`, `value`, `operator`, `mtime`) VALUES
	('cache.apc', 'ON', 'dba', '2013-07-18 16:17:13'),
	('cache.file.path', '/tmp', 'dba', '2013-07-18 16:17:57'),
	('cache.redis', 'YES', 'dba', '2013-07-18 16:17:22'),
	('payment.alipay.status', 'Enabled', 'dba', '2013-07-18 16:15:15'),
	('payment.alipay.url', 'http://xx.comx.com', 'dba', '2013-07-18 16:16:38'),
	('payment.yeepay.status', 'Enabled', 'dba', '2013-07-18 16:15:17'),
	('payment.99bill.status', 'Enabled', 'dba', '2013-07-18 16:15:10'),
	('payment.zqpay.status', 'Disabled', 'dba', '2013-07-18 16:15:20');
		
		</pre>
		<p>配置项key的写法很讲究</p>
		<pre class="screen">
单个配置
database.host=localhost
database.user=user
database.pass=pass

多个配置
database.1.host=localhost
database.1.user=user
database.1.pass=pass
database.1.status=1

database.2.host=localhost
database.2.user=user
database.2.pass=pass
database.2.status=1

优化配置项，例如：payment.alipay.status 可以这样优化
payment.status.alipay
payment.status.yeepay
		</pre>
		<p>这样做的目的是为了更好的使用like进行查询</p>
		<pre class="screen">
select `key`,`value` from config where `key` like 'payment.status.%';
select `key`,`value` from config where `key` like 'database.?.status';
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874394256"></a>3.1.14.1. 配置表历史记录</h4></div></div></div>
			
			<p>我有一个表，里面只有固定行数的行记录，这些数据就是配置参数，我们将配置文件保存在数据库中，因为需要做负载均衡而不能使用文件配置文件。</p>
			<p>有这样一个需求，这个记录每次修改都要保存历史记录，用于审计等等。我是这样设计该表的</p>
			<pre class="programlisting">
CREATE TABLE `config_fee` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`level` INT(11) NULL DEFAULT NULL COMMENT '层级',
	`type` ENUM('Deposit','Withdrawing') NOT NULL DEFAULT 'Withdrawing' COMMENT '类型，存款，取款',
	`min_fee` FLOAT(10,2) NOT NULL COMMENT '最低手续费',
	`max_fee` FLOAT(10,2) NOT NULL COMMENT '最高手续费',
	`ratio` FLOAT(10,2) NOT NULL COMMENT '手续费比例',
	`operator` VARCHAR(10) NOT NULL COMMENT '操作者',
	`status` ENUM('Current','Trash') NOT NULL DEFAULT 'Current',
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	`mtime` TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`)
)
COMMENT='手续费管理'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			</pre>
			<p>数据记录的形态</p>
			<pre class="screen">
			
mysql&gt; select type,operator,status,ctime,mtime from config_mtf_fee;
+---------+----------+---------+---------------------+---------------------+
| type    | operator | status  | ctime               | mtime               |
+---------+----------+---------+---------------------+---------------------+
| Deposit | 141      | Trash   | 2014-08-28 11:10:17 | 2014-08-28 11:10:57 |
| Deposit | 141      | Trash   | 2014-08-28 11:10:17 | 2014-08-28 11:10:57 |
| Deposit | 141      | Trash   | 2014-08-28 11:10:17 | 2014-08-28 11:10:57 |
| Deposit | 141      | Trash   | 2014-08-28 11:10:17 | 2014-08-28 11:10:57 |
| Deposit | 324      | Current | 2014-08-28 11:10:54 | 2014-08-28 11:10:59 |
+---------+----------+---------+---------------------+---------------------+
2 rows in set (0.00 sec)
						
			</pre>
			<p>如上图所示，状态 Current 是当前记录，而Trash是废弃的历史记录。</p>
			<p>每次修改数据，首先将Current改为Trash，然后插入一条新数据状态为Current，我们只会使用最后一条状态为current的数据。</p>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="captcha"></a>3.1.15. 验证码</h3></div></div></div>
		
		<p>用户注册，登陆等等需要验证码，下面的方案是，请求验证码生成一个随机验证码，存在code中，identity可以存储来源IP/手机号码/Cookie等等用户校验， 5分钟内如果没有被使用就会删除，如果5分钟内被使用也会删除。type 可以存放www,user,bbs,admin.....等等，将所有验证码放在captcha表中统一管理。</p>
		<p>这个方案主要是考虑没有memcache/redis/apc/xcache等等缓存环境下的解决方案，你也可以将下表改造一下，增加ttl字段用于存放生存时间，而不是采用5分钟一刀切的方案。</p>
		<pre class="programlisting">
CREATE TABLE `captcha` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`type` ENUM('user','admin') NOT NULL DEFAULT 'admin' COMMENT '验证码类型',
	`identity` VARCHAR(32) NOT NULL COMMENT '唯一身份识别md5摘要',
	`code` VARCHAR(6) NOT NULL COMMENT '验证码',
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
	PRIMARY KEY (`id`),
	UNIQUE INDEX `code` (`code`),
	UNIQUE INDEX `identity` (`identity`)
)
COMMENT='验证码'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
		</pre>
		<pre class="programlisting">
		
CREATE EVENT `captcha` ON SCHEDULE
		EVERY 5 MINUTE STARTS '2013-07-08 16:27:03'
	ON COMPLETION PRESERVE
	ENABLE
	COMMENT ''
	DO BEGIN
	delete from captcha where type='myid' and ctime &lt; DATE_ADD(now(), INTERVAL -5 MINUTE);
END
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="mobile"></a>3.1.16. 手机归属地数据库表</h3></div></div></div>
		
		<p>members_location 表与 members 表是一对一关系，该表只负责存储归属地信息</p>
		<pre class="programlisting">
DROP TABLE IF EXISTS `members_location`;
CREATE TABLE IF NOT EXISTS `members_location` (
  `id` int(10) unsigned NOT NULL,
  `province` varchar(50) NOT NULL,
  `city` varchar(50) NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `province` (`province`),
  KEY `city` (`city`),
  CONSTRAINT `FK_members_location_members` FOREIGN KEY (`id`) REFERENCES `members` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
		</pre>
		<p>当某些用户符合条件需要查询归属地是，只要将其插入到 members_mobile 表即可。该表使用黑洞引擎并不会存储手机号码，所以明文手机号码安全得到了保障。</p>
		<pre class="programlisting">
DROP TABLE IF EXISTS `members_mobile`;
CREATE TABLE IF NOT EXISTS `members_mobile` (
  `id` int(10) NOT NULL,
  `number` varchar(11) NOT NULL
) ENGINE=BLACKHOLE DEFAULT CHARSET=utf8;
		</pre>
		<p>当有数据进入到 members_mobile 时出发器 members_mobile_insert 会工作，去 mobile_location 表中查询归属地后保存在 members_location 表中 </p>
		<pre class="programlisting">
DROP TRIGGER IF EXISTS `members_mobile_insert`;
SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='';
DELIMITER //
CREATE TRIGGER `members_mobile_insert` BEFORE INSERT ON `members_mobile` FOR EACH ROW BEGIN
	insert into members_location(id,province,city) select NEW.id,mobile_location.province,mobile_location.city from  mobile_location where mobile_location.id = md5(LEFT(NEW.number, 7));
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;
		</pre>
		<p>mobile_location 是存储手机号段与归属地信息的数据库</p>
		<pre class="programlisting">
DROP TABLE IF EXISTS `mobile_location`;
CREATE TABLE IF NOT EXISTS `mobile_location` (
  `id` varchar(50) NOT NULL,
  `province` varchar(50) DEFAULT NULL,
  `city` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="data.check"></a>3.1.17. 数据检查</h3></div></div></div>
		
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874376048"></a>3.1.17.1. 身份证校验</h4></div></div></div>
			
			<p>该函数能够检查身份证号码是否正确</p>
			<pre class="programlisting">
			
CREATE DEFINER=`neo`@`%` FUNCTION `check_id_number`(`idnumber` CHAR(18))
	RETURNS enum('true','false')
	LANGUAGE SQL
	NOT DETERMINISTIC
	NO SQL
	SQL SECURITY DEFINER
	COMMENT ''
BEGIN
DECLARE status ENUM('true','false') default 'false';
DECLARE verify CHAR(1);
DECLARE sigma INT;
DECLARE remainder INT;

IF length(idnumber) = 18 THEN
	set sigma = cast(substring(idnumber,1,1) as UNSIGNED) * 7
		+cast(substring(idnumber,2,1) as UNSIGNED) * 9
		+cast(substring(idnumber,3,1) as UNSIGNED) * 10
		+cast(substring(idnumber,4,1) as UNSIGNED) * 5
		+cast(substring(idnumber,5,1) as UNSIGNED) * 8
		+cast(substring(idnumber,6,1) as UNSIGNED) * 4
		+cast(substring(idnumber,7,1) as UNSIGNED) * 2
		+cast(substring(idnumber,8,1) as UNSIGNED) * 1
		+cast(substring(idnumber,9,1) as UNSIGNED) * 6
		+cast(substring(idnumber,10,1) as UNSIGNED) * 3
		+cast(substring(idnumber,11,1) as UNSIGNED) * 7
		+cast(substring(idnumber,12,1) as UNSIGNED) * 9
		+cast(substring(idnumber,13,1) as UNSIGNED) * 10
		+cast(substring(idnumber,14,1) as UNSIGNED) * 5
		+cast(substring(idnumber,15,1) as UNSIGNED) * 8
		+cast(substring(idnumber,16,1) as UNSIGNED) * 4
		+cast(substring(idnumber,17,1) as UNSIGNED) * 2;
	set remainder = MOD(sigma,11);
	set verify = (case remainder
		when 0 then '1' when 1 then '0' when 2 then 'X' when 3 then '9'
		when 4 then '8' when 5 then '7' when 6 then '6' when 7 then '5'
		when 8 then '4' when 9 then '3' when 10 then '2' else '/' end
	);

END IF;

IF right(idnumber,1) = verify THEN
	set status = 'true';
END IF;

RETURN status;

END
			
			</pre>
			<p>首先我们使用正确身份证号码进行测试，返回true</p>
			<pre class="screen">
			
mysql&gt; select check_id_number('330702198003090915');
+---------------------------------------+
| check_id_number('330702198003090915') |
+---------------------------------------+
| true                                  |
+---------------------------------------+
1 row in set (0.01 sec)
			
			</pre>
			<p>长度不符合18位直接返回false.</p>
			<pre class="screen">
			
mysql&gt; select check_id_number('33070219800309');
+-----------------------------------+
| check_id_number('33070219800309') |
+-----------------------------------+
| false                             |
+-----------------------------------+
1 row in set (0.00 sec)	

mysql&gt; select check_id_number('33070219800309091457889');
+--------------------------------------------+
| check_id_number('33070219800309091457889') |
+--------------------------------------------+
| false                                      |
+--------------------------------------------+
1 row in set, 1 warning (0.00 sec)
			
			</pre>
			<p>随便改译为数，校验失败返回 false</p>
			<pre class="screen">
			
mysql&gt; select check_id_number('330702198003090914');
+---------------------------------------+
| check_id_number('330702198003090914') |
+---------------------------------------+
| false                                 |
+---------------------------------------+
1 row in set (0.00 sec)					
			
			</pre>
		</div>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="current_timestamp"></a>3.1.18. 创建与修改时间</h3></div></div></div>
		
		<p>ctime 为创建时间, mtime 是修改时间默认CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p>
		<pre class="programlisting">
CREATE TABLE `trades_platform` (
	`id` INT(10) UNSIGNED NULL DEFAULT NULL,
	`type` ENUM('A','B','C') NOT NULL,
	`login` VARCHAR(10) NOT NULL,
	`password` VARCHAR(10) NOT NULL,
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	`mtime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
)
COMMENT='平台'
ENGINE=InnoDB;
		</pre>
		<p>我们还可以让mtime默认为NULL,这样更节省存储空间。</p>
		<pre class="screen">
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	`mtime` TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="employees_online"></a>3.1.19. 在线用户表</h3></div></div></div>
		
		<p>该表的功能是显示在线用户，控制多点登陆，防止异常退出</p>
		<pre class="programlisting">
		
CREATE TABLE IF NOT EXISTS `employees_online` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(20) NOT NULL COMMENT 'User ID',
  `ipaddr` varchar(15) NOT NULL COMMENT 'IP Address',
  `expire` datetime NOT NULL COMMENT 'Expire time',
  `status` enum('Login','Logout','Offline') NOT NULL DEFAULT 'Login' COMMENT 'Current Status',
  `message` varchar(255) NOT NULL COMMENT 'Leave a message',
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Created Time',
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT 'Modified Time',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='show listing of last logged in users';

DELIMITER //
CREATE DEFINER=`dba`@`192.168.%` EVENT `employees_online` ON SCHEDULE EVERY 15 MINUTE STARTS '2014-08-22 10:33:24' ON COMPLETION NOT PRESERVE ENABLE COMMENT 'Employees Online Logging' DO BEGIN
	update employees_online set `status` = 'Offline' where expire &lt; now() and ctime &gt; DATE_ADD(now(), INTERVAL -15 MINUTE);
END//
DELIMITER ;

SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_ENGINE_SUBSTITUTION';
DELIMITER //
CREATE TRIGGER `employees_online_before_delete` BEFORE DELETE ON `employees_online` FOR EACH ROW BEGIN
	SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Permission denied', MYSQL_ERRNO = 1001;
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;

SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_ENGINE_SUBSTITUTION';
DELIMITER //
CREATE TRIGGER `employees_online_before_update` BEFORE UPDATE ON `employees_online` FOR EACH ROW BEGIN
	SET NEW.`id` = OLD.id;
	SET NEW.`username` = OLD.username;
	SET NEW.`ipaddr` = OLD.ipaddr;
	SET NEW.`message` = OLD.message;
	SET NEW.`ctime` = OLD.ctime;
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;	
			
		</pre>
		<p>登陆日志将永久保存，防止数据被删除由触发器employees_online_before_delete负责</p>
		<p>防止有人撰改登陆信息，由触发器employees_online_before_update负责，主要是防止撰改登陆名与IP地址，这样讲不能从其他电脑登陆，必须用户Logout才能在其他电脑登陆。</p>
	</div>
	
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="html2text"></a>3.1.20. HTML TO Text</h3></div></div></div>
		
		<p>实现 PHP strip_tags 函数的功能。</p>
		<pre class="programlisting">
		
CREATE DEFINER=`dba`@`%` FUNCTION `strip_tags`(`$str` TEXT)
RETURNS text CHARSET utf8
LANGUAGE SQL
NOT DETERMINISTIC
CONTAINS SQL
SQL SECURITY DEFINER
COMMENT ''
BEGIN
    DECLARE $start, $end INT DEFAULT 1;
    LOOP
        SET $start = LOCATE("&lt;", $str, $start);
        IF (!$start) THEN RETURN $str; END IF;
        SET $end = LOCATE("&gt;", $str, $start);
        IF (!$end) THEN SET $end = $start; END IF;
        SET $str = INSERT($str, $start, $end - $start + 1, "");
    END LOOP;
END		
		
		</pre>
		<pre class="screen">
		
mysql&gt; select strip_tags('&lt;span&gt;&lt;i&gt;hello&lt;/i&gt; &lt;b&gt;world&lt;/b&gt;!!! &lt;br /&gt;&lt;a href="//www.netkiller/"&gt;netkiller&lt;/a&gt;');
+----------------------------------------------------------------------+
| strip_tags('&lt;span&gt;hel&lt;b&gt;lo &lt;a href="world"&gt;wo&lt;&gt;rld&lt;/a&gt; &lt;&lt;x&gt;again&lt;.') |
+----------------------------------------------------------------------+
| hello world again.                                                   |
+----------------------------------------------------------------------+
1 row in set

mysql&gt; select strip_tags('&lt;span style="color:red"&gt;&lt;i&gt;hello&lt;/i&gt; &lt;b id="world" &gt;world&lt;/b&gt;!!! &lt;br /&gt;&lt;a class="home" href="//www.netkiller/"&gt;netkiller&lt;/a&gt;&lt;span&gt;') as TEXT;
+--------------------------+
| TEXT                     |
+--------------------------+
| hello world!!! netkiller |
+--------------------------+
1 row in set (0.00 sec)
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="sns"></a>3.1.21. SNS 数据库设计</h3></div></div></div>
		
		<p>这里讲解SNS交友社区的数据库设计与实现</p>
		<p>我们要实现下面几个功能</p>
		<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">朋友之间的关系，多对多关系</li><li class="listitem">朋友之间的维度，如3度4度....</li><li class="listitem">朋友的查找</li></ol></div>
		<pre class="programlisting">
		
CREATE DATABASE `sns` /*!40100 COLLATE 'utf8_general_ci' */
		
		</pre>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874356240"></a>3.1.21.1. people 表</h4></div></div></div>
			
			<p>people 是存储人，你可以用为user,member都可以</p>
			<pre class="programlisting">
			
CREATE TABLE `people` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(50) NOT NULL,
	PRIMARY KEY (`id`)
)
COMMENT='Social Network Site - Six Degrees of Separation - http://www.netkiller.cn'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
			</pre>
			<p>存储具体的这人</p>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874353776"></a>3.1.21.2. firend 表</h4></div></div></div>
			
			<p>这个表的功能主要是维持朋友之间的关系网，这里使用了多对多方式并且使用外键防止产生脏数据。</p>
			<pre class="programlisting">
			
CREATE TABLE `friend` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`people_id` INT(10) UNSIGNED NOT NULL,
	`friend_id` INT(10) UNSIGNED NOT NULL,
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`),
	UNIQUE INDEX `unique` (`people_id`, `friend_id`),
	INDEX `FK_firend_people` (`people_id`),
	INDEX `FK_firend_people_2` (`friend_id`),
	CONSTRAINT `FK_firend_people` FOREIGN KEY (`people_id`) REFERENCES `people` (`id`),
	CONSTRAINT `FK_firend_people_2` FOREIGN KEY (`friend_id`) REFERENCES `people` (`id`)
)
COMMENT='Social Network Site - Six Degrees of Separation - http://www.netkiller.cn'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;

			
			</pre>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874352016"></a>3.1.21.3. 演示</h4></div></div></div>
			
			<p>首先初始化用户数据</p>
			<pre class="programlisting">
			
INSERT INTO `people` (`id`, `name`) VALUES
	(1, 'Neo'),
	(2, 'Luke'),
	(3, 'Jack'),
	(4, 'Joey'),
	(5, 'Jam'),
	(6, 'John');
			
			</pre>
			<p>建立朋友之间的关系</p>
			<pre class="programlisting">
			
INSERT INTO `friend` (`id`, `people_id`, `friend_id`) VALUES
	(1, 1, 2),
	(2, 1, 3),
	(3, 1, 4),
	(4, 1, 5),
	(5, 1, 6),
	(6, 2, 1),
	(7, 2, 3);
			
			</pre>
			<p>现在就可以查找你的朋友了</p>
			<pre class="programlisting">
			
select people.* from friend, people where friend.people_id = 1 and friend.friend_id = people.id;
			
			</pre>
			<p>查找朋友的朋友就比较麻烦了，必须使用递归方法，一层一层查下去，反复执行SQL效率是很低的，所以我们准备了第三张表。</p>
		</div>
		<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874346976"></a>3.1.21.4. network 表</h4></div></div></div>
			
			<p>关系网表，主要功能是弥补firend表，用于快速检索（在不使用递归的情况下）</p>
			<pre class="programlisting">
			
CREATE TABLE `network` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`people_id` INT(10) UNSIGNED NOT NULL,
	`following_id` INT(10) UNSIGNED NOT NULL,
	`friend_id` INT(10) UNSIGNED NULL DEFAULT NULL,
	`degrees` VARCHAR(250) NOT NULL,
	`ctime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
	PRIMARY KEY (`id`),
	UNIQUE INDEX `unique` (`people_id`, `friend_id`, `following_id`),
	INDEX `FK_firend_people` (`people_id`),
	INDEX `FK_firend_people_2` (`friend_id`),
	INDEX `FK_friend_people_following_id` (`following_id`),
	CONSTRAINT `FK_firend_people` FOREIGN KEY (`people_id`) REFERENCES `people` (`id`),
	CONSTRAINT `FK_friend_people_following_id` FOREIGN KEY (`following_id`) REFERENCES `people` (`id`),
	CONSTRAINT `FK_friend_people_friend_id` FOREIGN KEY (`friend_id`) REFERENCES `people` (`id`)
)
COMMENT='Social Network Site - Six Degrees of Separation - http://www.netkiller.cn'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;

			
			</pre>
			<p>following 一个朋友, Neo following Jam</p>
			<pre class="programlisting">
			
INSERT INTO `people` (`id`, `name`) VALUES
	(1, 'Neo'),
	(2, 'Luke'),
	(3, 'Jack'),
	(4, 'Joey'),
	(5, 'Jam'),
	(6, 'John');

INSERT INTO `network` (`people_id`, `following_id`, `friend_id`, `degrees`) VALUES ( 1, 5, NULL, '1.5');
			
			</pre>
			<p>之前Neo已经 following Jam，接下来查找Jam的朋友，现在Neo following John, John 是 Jam 的朋友，friend_id = NULL 表示 Jam 尚未有朋友</p>
			<pre class="programlisting">
			
select * from network where people_id=1 and friend_id = 5;

INSERT INTO `sns`.`network` (`people_id`, `following_id`, `friend_id`, `degrees`) VALUES ('1', '6', '5', '1.5.6');
			
			</pre>
			<p>Neo following Joey, Joey 是 Luke 的朋友， 所以 Luke可能是 Neo的朋友</p>
			<pre class="programlisting">
			
INSERT INTO `sns`.`network` (`people_id`, `following_id`, `friend_id`, `degrees`) VALUES ('1', '4', '2', '1.2.4');
			
			</pre>
			
			<p>查询不同维度下的所有好友，查询出的用户ID需要处理。</p>
			<pre class="programlisting">
			
select * from network where people_id=1 and degrees like "1.%";
select * from network where people_id=1 and degrees like "1.2%";
select * from network where people_id=1 and degrees like "1.2.%";
			
			</pre>
			<p>至此社区管理网就建立起来了</p>
			<p>上面的例子演示了 people_id=1 即 Neo 的关系网</p>
		</div>
	</div>
	

<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="db.cache"></a>3.1.22. 数据库与缓存</h3></div></div></div>
	

	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="what"></a>3.1.22.1. 什么是数据库缓存？</h4></div></div></div>
		
		<p>这里讲的缓存是数据库本身的缓存，并不是外部缓存例如Redis/Memcache等等。</p>
		<p>数据库的数据分为冷数据和热数据库，通俗的讲冷数据是存储在磁盘上不经常查询的数据；而热数据是频繁查询的数据，这部分数据会被缓存到内存中。</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="why"></a>3.1.22.2. 为什么缓存数据呢？</h4></div></div></div>
		
		<p>因为频繁查询相同结果集的数据时，每次到磁盘上查找数据是非常耗时的，所以数据库将频繁查询且返回相同结果集的数据放到内存中，可以减少磁盘访问操作。</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="when"></a>3.1.22.3. 什么时候使用数据库缓存</h4></div></div></div>
		
		<p>频繁访问且返回相同结果集的情况下使用缓存。</p>
		<p>偶尔查询一次且间隔时间较长的情况下不要使用缓存。</p>
		<p>尺寸较大的结果集不建议使用缓存，因为数据太大太大，缓存不足以存储，会导致频繁载入与销毁，命中率低。</p>
		<p>通常数据库默认情况是开启缓存的，也就是说正常的select查询，如果符合缓存规则就会经过缓存。</p>
		<p>当一条SQL查询时如果结果集在内存中称作“命中”</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="where"></a>3.1.22.4. 涉及缓存的地方有哪些</h4></div></div></div>
		
		<p>数据库本身，查看数据库缓存状态</p>
		<p>数据库应用程序接口（ODBC、JDBC......）</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="who"></a>3.1.22.5. 谁来控制数据库缓存</h4></div></div></div>
		
		<p>通常DBA只能控制数据库缓存是否开启，分配多少内存给缓存使用，过期销毁时间，以及策略等等.</p>
		<p>上面我已经说过，通常数据库默认都开启缓存，所以更多的时候我们的操作是禁用缓存。这就需要开发人员来通过特定的SQL操作来控制数据库缓存。</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="how"></a>3.1.22.6. 怎么控制数据库缓存</h4></div></div></div>
		
		<p>以 MySQL 为例</p>
		<pre class="screen">
		
mysql&gt; show variables like '%query_cache%'; 
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| have_query_cache             | YES     |
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 1048576 |
| query_cache_type             | OFF     |
| query_cache_wlock_invalidate | OFF     |
+------------------------------+---------+
6 rows in set (0.04 sec)		
		
		</pre>
		<p>编辑 my.cnf 文件，加入配置项 query_cache_type=1 然后重启mysql服务</p>
		<pre class="screen">
		
mysql&gt; show variables like '%query_cache%'; 
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| have_query_cache             | YES     |
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 1048576 |
| query_cache_type             | ON      |
| query_cache_wlock_invalidate | OFF     |
+------------------------------+---------+
6 rows in set (0.00 sec)		
		
		</pre>
		<p>query_cache_type | ON 表示缓存已经开启。</p>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idm452874321184"></a>3.1.22.6.1. SQL_CACHE 缓存</h5></div></div></div>
			
			<p>默认情况 select 查询操作只要符合数据库缓存规则那么结果集就会被缓存，如果你的数据库没有开启缓存，请参考下面</p>
			<pre class="screen">
			
set session query_cache_type=on;

flush tables;
show status like 'qcache_q%';
select sql_cache * from member where id=1;
show status like 'qcache_q%';
select sql_cache * from member where id=1;
show status like 'qcache_q%';
			
			</pre>
			<div class="example"><a id="idm452874319136"></a><p class="title"><strong>例 3.2. 演示 SQL_CACHE</strong></p><div class="example-contents">
				
				<pre class="screen">
				
mysql&gt; flush tables;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)

mysql&gt; select sql_cache * from member where id=1;
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
| id | age | ctime               | ip_address | mobile | mtime | name | picture | sex  | status | wechat |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
|  1 |   1 | 2017-08-24 17:05:43 | 1          | NULL   | NULL  | 1    | 1       | 1    | Enable | NULL   |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
1 row in set (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 1     |
+-------------------------+-------+
1 row in set (0.01 sec)

mysql&gt; select sql_cache * from member where id=1;
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
| id | age | ctime               | ip_address | mobile | mtime | name | picture | sex  | status | wechat |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
|  1 |   1 | 2017-08-24 17:05:43 | 1          | NULL   | NULL  | 1    | 1       | 1    | Enable | NULL   |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
1 row in set (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 1     |
+-------------------------+-------+
1 row in set (0.01 sec)
				
				</pre>
				<p>我们可以看到 Qcache_queries_in_cache 值由0转为1表示缓存已经生效。</p>
			</div></div><br class="example-break" />
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idm452874317264"></a>3.1.22.6.2. 禁止缓存 SQL_NO_CACHE</h5></div></div></div>
			
			<p>这里我们主要讲怎样禁止缓存，使查询出的结果集不进入缓存。</p>
			<pre class="screen">
SELECT SQL_NO_CACHE * FROM table where id=xxxx			
			</pre>
			<p>下面的用法比较安全，切换到其他数据库也能正常工作</p>
			<pre class="screen">
SELECT /*!40001 SQL_NO_CACHE */ * FROM table			
			</pre>
			<pre class="screen">
set session query_cache_type=on;

flush tables;
show status like 'qcache_q%';
select sql_no_cache * from member where id=1;
show status like 'qcache_q%';
select sql_no_cache * from member where id=1;
show status like 'qcache_q%';						
			</pre>
			<div class="example"><a id="idm452874313952"></a><p class="title"><strong>例 3.3. 演示 SQL_NO_CACHE</strong></p><div class="example-contents">
				
				<pre class="screen">
				
mysql&gt; flush tables;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)

mysql&gt; select sql_no_cache * from member where id=1;
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
| id | age | ctime               | ip_address | mobile | mtime | name | picture | sex  | status | wechat |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
|  1 |   1 | 2017-08-24 17:05:43 | 1          | NULL   | NULL  | 1    | 1       | 1    | Enable | NULL   |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
1 row in set (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)

mysql&gt; select sql_no_cache * from member where id=1;
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
| id | age | ctime               | ip_address | mobile | mtime | name | picture | sex  | status | wechat |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
|  1 |   1 | 2017-08-24 17:05:43 | 1          | NULL   | NULL  | 1    | 1       | 1    | Enable | NULL   |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
1 row in set (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)
				
				</pre>
				<p>使用 sql_no_cache 查询 Qcache_queries_in_cache 值始终是 0</p>
			</div></div><br class="example-break" />
		</div>
		<div class="section"><div class="titlepage"><div><div><h5 class="title"><a id="idm452874312096"></a>3.1.22.6.3. 关闭缓存 set session query_cache_type=off</h5></div></div></div>
			
			<p>我们使用 set session query_cache_type=off 可以关闭本次查询缓存。</p>
			<pre class="screen">
set session query_cache_type=off;

flush tables;
show status like 'qcache_q%';
select sql_cache * from member where id=1;
show status like 'qcache_q%';
select sql_cache * from member where id=1;
show status like 'qcache_q%';						
			</pre>
			<div class="example"><a id="idm452874310320"></a><p class="title"><strong>例 3.4. 演示 query_cache_type=off 关闭查询缓存</strong></p><div class="example-contents">
				
				<pre class="screen">
				
mysql&gt; set session query_cache_type=off;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; 
mysql&gt; flush tables;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)

mysql&gt; select sql_cache * from member where id=1;
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
| id | age | ctime               | ip_address | mobile | mtime | name | picture | sex  | status | wechat |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
|  1 |   1 | 2017-08-24 17:05:43 | 1          | NULL   | NULL  | 1    | 1       | 1    | Enable | NULL   |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
1 row in set (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)

mysql&gt; select sql_cache * from member where id=1;
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
| id | age | ctime               | ip_address | mobile | mtime | name | picture | sex  | status | wechat |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
|  1 |   1 | 2017-08-24 17:05:43 | 1          | NULL   | NULL  | 1    | 1       | 1    | Enable | NULL   |
+----+-----+---------------------+------------+--------+-------+------+---------+------+--------+--------+
1 row in set (0.00 sec)

mysql&gt; show status like 'qcache_q%';
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| Qcache_queries_in_cache | 0     |
+-------------------------+-------+
1 row in set (0.00 sec)
				
				
				</pre>
			</div></div><br class="example-break" />
		</div>
	</div>
</div>
	
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ordbms"></a>3.1.23. PostgreSQL 所特有数据库设计</h3></div><div><h4 class="subtitle">PostgreSQL 数据库 ORDBMS / OODBMS 等特有属性</h4></div></div></div>
	
	
	<p>对象相关数据库管理系统(ORDBMS Object – Oriented Relative DBMS)</p>
	<p></p>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="city"></a>3.1.23.1. 国家地区表的设计</h4></div></div></div>
		
			<pre class="screen">
			
 +-----------+
 | city      |
 |-----------|
 |id         | &lt;---+
 |name       |     |
 |description|    1:n
 |status     |     |
 |parent_id  | o---+
 +-----------+
			
			</pre>
	    <div class="example"><a id="idm452874305072"></a><p class="title"><strong>例 3.5. 递归查询实例 city 表</strong></p><div class="example-contents">
	    	
	    	<p>定义结构</p>
			<pre class="screen">
	    	
CREATE TABLE city
(
  id serial NOT NULL,
  name character varying,
  parent_id integer,
  status boolean,
  CONSTRAINT city_pkey PRIMARY KEY (id),
  CONSTRAINT city_parent_id_fkey FOREIGN KEY (parent_id)
      REFERENCES city (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
)
WITH (
  OIDS=FALSE
);
ALTER TABLE city
  OWNER TO sys;
	    	
	    	</pre>
	    	<p>插入数据</p>
	    	<pre class="screen">
	    	
INSERT INTO city (id, name, parent_id, status) VALUES (1, '广东', NULL, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (2, '湖南', NULL, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (3, '深圳', 1, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (4, '东莞', 1, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (5, '福田', 3, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (6, '南山', 3, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (7, '宝安', 3, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (8, '西乡', 7, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (9, '福永', 7, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (10, '龙华', 7, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (11, '长沙', 2, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (12, '湘潭', 2, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (13, '常德', 2, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (14, '桃源', 13, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (15, '汉寿', 13, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (16, '黑龙江', NULL, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (17, '伊春', 16, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (18, '哈尔滨', 16, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (19, '齐齐哈尔', 16, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (20, '牡丹江', 16, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (21, '佳木斯', 16, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (22, '民治', 10, NULL);
INSERT INTO city (id, name, parent_id, status) VALUES (23, '上塘', 10, NULL);
	    	
	    	</pre>
			<p>查询</p>
	    	<pre class="screen">
	    	
WITH RECURSIVE path(id, name, path, idpath, parent_id, status) AS (
  SELECT id, name, '/' || name , '/' || id , parent_id, status FROM city WHERE parent_id is null
  UNION
  SELECT
    city.id,
    city.name,
    parentpath.path ||
      CASE parentpath.path
	WHEN '/' THEN ''
	ELSE '/'
      END || city.name,
    parentpath.idpath ||
     CASE parentpath.idpath
	WHEN '/' THEN ''
	ELSE '/'
      END || city.id,
    city.parent_id, city.status
  FROM city, path as parentpath
  WHERE city.parent_id = parentpath.id
)

SELECT * FROM path;
	    	
	    	</pre>
	    	<p>结果输出</p>
	    	<pre class="screen">
	    	
 id |   name   |           path            |    idpath    | parent_id | status
----+----------+---------------------------+--------------+-----------+--------
  1 | 广东     | /广东                     | /1           |           |
  2 | 湖南     | /湖南                     | /2           |           |
 16 | 黑龙江   | /黑龙江                   | /16          |           |
  3 | 深圳     | /广东/深圳                | /1/3         |         1 |
  4 | 东莞     | /广东/东莞                | /1/4         |         1 |
 11 | 长沙     | /湖南/长沙                | /2/11        |         2 |
 12 | 湘潭     | /湖南/湘潭                | /2/12        |         2 |
 13 | 常德     | /湖南/常德                | /2/13        |         2 |
 17 | 伊春     | /黑龙江/伊春              | /16/17       |        16 |
 18 | 哈尔滨   | /黑龙江/哈尔滨            | /16/18       |        16 |
 19 | 齐齐哈尔 | /黑龙江/齐齐哈尔          | /16/19       |        16 |
 20 | 牡丹江   | /黑龙江/牡丹江            | /16/20       |        16 |
 21 | 佳木斯   | /黑龙江/佳木斯            | /16/21       |        16 |
  5 | 福田     | /广东/深圳/福田           | /1/3/5       |         3 |
  6 | 南山     | /广东/深圳/南山           | /1/3/6       |         3 |
  7 | 宝安     | /广东/深圳/宝安           | /1/3/7       |         3 |
 14 | 桃源     | /湖南/常德/桃源           | /2/13/14     |        13 |
 15 | 汉寿     | /湖南/常德/汉寿           | /2/13/15     |        13 |
  8 | 西乡     | /广东/深圳/宝安/西乡      | /1/3/7/8     |         7 |
  9 | 福永     | /广东/深圳/宝安/福永      | /1/3/7/9     |         7 |
 10 | 龙华     | /广东/深圳/宝安/龙华      | /1/3/7/10    |         7 |
 22 | 民治     | /广东/深圳/宝安/龙华/民治 | /1/3/7/10/22 |        10 |
 23 | 上塘     | /广东/深圳/宝安/龙华/上塘 | /1/3/7/10/23 |        10 |
(23 rows)
	    	
	    	</pre>
	    </div></div><br class="example-break" />
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="discuss"></a>3.1.23.2. 话题讨论表的设计</h4></div></div></div>
		
	    <div class="example"><a id="idm452874298752"></a><p class="title"><strong>例 3.6. 话题讨论表的设计</strong></p><div class="example-contents">
	        
	        <p>http://justcramer.com/2010/05/30/scaling-threaded-comments-on-django-at-disqus/</p>
	        <pre class="screen">
	        
create table comments (
    id SERIAL PRIMARY KEY,
    message VARCHAR,
    author VARCHAR,
    parent_id INTEGER REFERENCES comments(id)
);
insert into comments (message, author, parent_id)
    values ('This thread is really cool!', 'David', NULL), ('Ya David, we love it!', 'Jason', 1), ('I agree David!', 'Daniel', 1), ('gift Jason', 'Anton', 2),
    ('Very interesting post!', 'thedz', NULL), ('You sir, are wrong', 'Chris', 5), ('Agreed', 'G', 5), ('Fo sho, Yall', 'Mac', 5);
			
	        </pre>

			<pre class="screen">
			
WITH RECURSIVE cte (id, message, author, path, parent_id, depth)  AS (
    SELECT  id,
        message,
        author,
        array[id] AS path,
        parent_id,
        1 AS depth
    FROM    comments
    WHERE   parent_id IS NULL

    UNION ALL

    SELECT  comments.id,
        comments.message,
        comments.author,
        cte.path || comments.id,
        comments.parent_id,
        cte.depth + 1 AS depth
    FROM    comments
    JOIN cte ON comments.parent_id = cte.id
    )
    SELECT id, message, author, path, depth FROM cte ORDER BY path;
	    	
			</pre>
			<p>输出结果</p>
			<pre class="screen">
 id |           message           | author |  path   | depth
----+-----------------------------+--------+---------+-------
  1 | This thread is really cool! | David  | {1}     |     1
  2 | Ya David, we love it!       | Jason  | {1,2}   |     2
  4 | gift Jason                  | Anton  | {1,2,4} |     3
  3 | I agree David!              | Daniel | {1,3}   |     2
  5 | Very interesting post!      | thedz  | {5}     |     1
  6 | You sir, are wrong          | Chris  | {5,6}   |     2
  7 | Agreed                      | G      | {5,7}   |     2
  8 | Fo sho, Yall                | Mac    | {5,8}   |     2
(8 rows)
		    </pre>
	    </div></div><br class="example-break" />
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="account"></a>3.1.23.3. 账户表/余额表/消费储蓄表</h4></div></div></div>
		
		<p>此表适用于购物车等金钱来往账面等等。</p>
		<pre class="programlisting">
		
-- Table: account

-- DROP TABLE account;

CREATE TABLE account
(
  id integer NOT NULL DEFAULT nextval('trade_id_seq'::regclass),
  no character varying(10) NOT NULL, -- 账号
  balance money NOT NULL DEFAULT 0.00, -- 余额
  datetime timestamp without time zone NOT NULL DEFAULT (now())::timestamp(0) without time zone,
  CONSTRAINT account_pkey PRIMARY KEY (id)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE account
  OWNER TO dba;
COMMENT ON COLUMN account.no IS '账号';
COMMENT ON COLUMN account.balance IS '余额';


-- Index: account_no_idx

-- DROP INDEX account_no_idx;

CREATE INDEX account_no_idx
  ON account
  USING btree
  (no COLLATE pg_catalog."default");
		
		
		</pre>
		<p>账户结余计算</p>
		<pre class="screen">
		
select acc.*, (select sum(balance)+acc.balance from account as ac where ac.id &lt; acc.id) as profit from account as acc;

test=# select acc.*, (select sum(balance)+acc.balance from account as ac where ac.id &lt; acc.id) as profit from account as acc;
 id |  no  | balance  |      datetime       | profit
----+------+----------+---------------------+---------
  1 | 1000 |    $0.00 | 2013-10-09 10:51:10 |
  2 | 1000 |   $12.60 | 2013-10-09 10:51:22 |  $12.60
  4 | 1000 |   $16.80 | 2013-10-09 10:51:42 |  $29.40
  5 | 1000 |  $100.00 | 2013-10-09 10:51:49 | $129.40
  6 | 1000 |  $200.00 | 2013-10-09 10:56:35 | $329.40
  7 | 1000 |   $50.45 | 2013-10-09 10:57:23 | $379.85
  8 | 1000 |   $75.50 | 2013-10-09 10:57:31 | $455.35
  9 | 1000 |  -$55.30 | 2013-10-09 10:59:28 | $400.05
 10 | 1000 | -$200.00 | 2013-10-09 10:59:44 | $200.05
(9 rows)
				
		</pre>
	</div>
</div>
	
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="db.parallel"></a>3.1.24. 数据库并行访问控制</h3></div></div></div>
	
	<p>这里主要讲述有关开发中遇到的数据库并行问题</p>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="show"></a>3.1.24.1. 防止并行显示</h4></div></div></div>
		
		<div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>背景</strong></p></div></div></div>
			
			<p>我们有一个order订单表，工作流如下</p>
			<pre class="screen">
			
创建订单 -&gt; 订单分配 -&gt; 订单审核 -&gt; 批准 -&gt; 发货 ... 等等			
			
			</pre>
			<p>有多个岗位，每个岗位上有多个工作人员。需要实现相同岗位上的工作人员看到的订单不能重复，防止多人同时操作一个订单。</p>
		</div>
		<pre class="screen">
id | user | sn    | status
-----------------------------------
1  | neo  | x001  | new
2  | jam  | x002  | new
3  | sam  | x003  | new
4  | tom  | x004  | new
5  | ann  | x005  | new
6  | leo  | x006  | new
7  | ant  | x007  | new
8  | cat  | x008  | new
		</pre>
		<p>正常情况只要是多人一起打开订单页面就会显示上面的订单，并且每个人显示的内容都相同。</p>
		<pre class="screen">
CREATE TABLE `orders` (
	`id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(50) NOT NULL,
	`sn` INT(10) UNSIGNED ZEROFILL NOT NULL,
	`status` ENUM('New','Pending','Processing','Success','Failure') NOT NULL DEFAULT 'New',
	PRIMARY KEY (`id`),
	UNIQUE INDEX `sn` (`sn`)
)
COMMENT='订货单'
COLLATE='utf8_general_ci'
ENGINE=InnoDB	
		</pre>
		<pre class="screen">
INSERT INTO `orders` (`id`, `name`, `sn`, `status`) VALUES
	(1, 'neo', 0000000001, 'New'),
	(2, 'jam', 0000000002, 'New'),
	(3, 'sam', 0000000003, 'New'),
	(4, 'tom', 0000000004, 'New'),
	(5, 'ann', 0000000005, 'New'),
	(6, 'leo', 0000000006, 'New'),
	(7, 'ant', 0000000007, 'New'),
	(8, 'cat', 0000000008, 'New');
		</pre>
		
		<div class="table"><a id="idm452874285056"></a><p class="title"><strong>表 3.1. 工作流模拟</strong></p><div class="table-contents">
			
			<table class="table" summary="工作流模拟" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>操作</th><th>订单审核员 A</th><th>订单审核员 B</th></tr></thead><tbody><tr><td>
							显示未处理订单,这里模拟两个人同时点开页面的情景
						</td><td>
							<pre class="programlisting">
begin;
select id from orders where status='New' limit 5 for update;
update orders set status='Pending' where status='New' and id in (1,2,3,4,5);
select * from orders where status='Pending' and id in (1,2,3,4,5) order by id asc limit 5;
commit;
							</pre>
							<p>首先查询出数据库中的前五条记录，然后更新为Pending状态，防止他人抢占订单。</p>
						</td><td>
							<pre class="programlisting">
begin;
select id from orders where status='New' limit 5 for update;
update orders set status='Pending' where status='New' and id in (6,7,8);
select * from orders where status='Pending' and id in (6,7,8) order by id asc limit 5;
commit;
							</pre>
							<p>select的时候会被行级所挂起，直到被commit后才能查询出新数据，这是显示的数据是剩下的后5条</p>
						</td></tr><tr><td>
							处理订单，模拟两个人点击审批通过按钮是的情景
						</td><td>
							<pre class="programlisting">
begin;							
select * from orders where status='Pending' and id='1' for update;
update orders set status='Processing' where status='Pending' and id=1;
commit;
							</pre>
							<p>更新状态Pending到Processing</p>
						</td><td>
							<pre class="programlisting">
begin;							
select * from orders where status='Pending' and id='6' for update;
update orders set status='Processing' where status='Pending' and id=6;
commit;
							</pre>
							<p>更新状态Pending到Processing</p>
						</td></tr><tr><td>
							处理成功与失败的情况
						</td><td>
							<pre class="programlisting">
begin;							
select * from orders where status='Processing' and id='1' for update;
update orders set status='Success' where status='Processing' and id=1;
commit;
							</pre>
						</td><td>
							<pre class="programlisting">
begin;							
select * from orders where status='Processing' and id='6' for update;
update orders set status='Failure' where status='Processing' and id=6;
commit;
							</pre>
						</td></tr><tr><td>
							处理Pending状态的订单，可能产生冲突，不用担心有行锁，防止重复处理。
						</td><td>
							<pre class="programlisting">
begin;							
select * from orders where status='Processing' and id='5' for update;
update orders set status='Failure' where status='Processing' and id=5;
commit;
							</pre>
						</td><td>
							<pre class="programlisting">
begin;							
select * from orders where status='Processing' and id='5' for update;
update orders set status='Failure' where status='Processing' and id=5;
commit;
							</pre>
						</td></tr></tbody></table>
		</div></div><br class="table-break" />
		<p>有一种情况，用户查看了列表并未及时处理订单，就会有很多Pending状态的订单，这是需要有人处理这些订单，但查询Pending时，可能同一时刻有人在审批订单，我们通过排他锁避免重复处理。</p>
		<p>上面以MySQL为例，每次都需要使用for update 查出要处理的订单，如果是PostgreSQL 可以使用update + returning 来返回修改的数据，更为方便。</p>
	</div>

</div>
	
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="sharding"></a>3.1.25. Sharding</h3></div></div></div>
	
	<p>Sharding是近几年提出的概念，可以做分表，分库切割，通过hash值定位。但都存在一个问题，数据连续性，索引无法跨表。</p>
	<p>Oracle 在8.x中就支持分区功能，MySQL在5.1.x中也是闲类似功能，PostgreSQL 因存储结构设计的较好，基本不需要做分区。</p>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sharding.horizontal"></a>3.1.25.1. horizontal</h4></div></div></div>
		
		<pre class="screen">
		
ALTER TABLE `goods`  DROP INDEX `goods_sn_2`;
ALTER TABLE goods PARTITION BY RANGE (goods_id) (
    PARTITION p0 VALUES LESS THAN (10000),
    PARTITION p1 VALUES LESS THAN (20000),
    PARTITION p2 VALUES LESS THAN (30000),
    PARTITION p3 VALUES LESS THAN (40000),
    PARTITION p4 VALUES LESS THAN MAXVALUE
);

ALTER TABLE goods PARTITION BY HASH(goods_id) PARTITIONS 10;

ALTER TABLE goods  PARTITION BY KEY (is_on_sale) PARTITIONS 2;

ALTER TABLE goods PARTITION BY HASH(YEAR(FROM_UNIXTIME(add_time))) PARTITIONS 4;
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sharding.vertical"></a>3.1.25.2. vertical</h4></div></div></div>
		

	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="sharding.news"></a>3.1.25.3. 新闻数据库分表案例</h4></div></div></div>
		
		<p>这里我通过一个新闻网站为例，解决分表的问题</p>
		<p>避免开发中经常拼接表，我采用一个一劳永逸的方法，建立一个 news 表使用黑洞引擎，然后通过出发器将数据分流到匹配的表中。同时采用uuid替代数字序列，可以保证未来数年不会出现ID用尽。</p>
		<pre class="programlisting">
		
CREATE TABLE IF NOT EXISTS `news` (
  `uuid` varchar(36) NOT NULL COMMENT '唯一ID',
  `title` varchar(50) NOT NULL COMMENT '新闻标题',
  `body` text NOT NULL COMMENT '新闻正文',
  `ctime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '创建时间',
  `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `atime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '访问时间',
  PRIMARY KEY (`uuid`)
) ENGINE=BLACKHOLE DEFAULT CHARSET=utf8;
		
		</pre>
		<p>该表仅仅用于举例，结构比较简单。接下来创建年份分表，你也可以每个月一个表，根据你的许下灵活调整。表结构与上面的news表相同，注意 ENGINE=InnoDB。</p>
		<pre class="programlisting">
		
CREATE TABLE IF NOT EXISTS `news_2012` (
  `uuid` varchar(36) NOT NULL COMMENT '唯一ID',
  `title` varchar(50) NOT NULL COMMENT '新闻标题',
  `body` text NOT NULL COMMENT '新闻正文',
  `ctime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '创建时间',
  `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `atime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '访问时间',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='news 表';

CREATE TABLE IF NOT EXISTS `news_2013` (
  `uuid` varchar(36) NOT NULL COMMENT '唯一ID',
  `title` varchar(50) NOT NULL COMMENT '新闻标题',
  `body` text NOT NULL COMMENT '新闻正文',
  `ctime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '创建时间',
  `mtime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `atime` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' COMMENT '访问时间',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='news 表';
		
		</pre>
		<p>uuid 索引表，主要的功能是通过uuid查询出该记录在那张表中。更好的方案是将数据放入solr中处理，包括标题与内容搜索等等。</p>
		<pre class="programlisting">
		
CREATE TABLE `news_index` (
	`uuid` VARCHAR(36) NOT NULL,
	`tbl_name` VARCHAR(10) NOT NULL,
	PRIMARY KEY (`uuid`)
)
COMMENT='news uuid 索引表'
COLLATE='utf8_general_ci'
ENGINE=InnoDB;

		
		</pre>
		<p>news_insert 过程，用于向目标表中插入数据，可以单独call 但不建议。因为insert 远比 call 更通用，要考虑移植性与通用性</p>
		<pre class="programlisting">
		
DELIMITER //
CREATE DEFINER=`neo`@`%` PROCEDURE `news_insert`(IN `uuid` vARCHAR(36), IN `title` VARCHAR(50), IN `body` TEXT, IN `ctime` TIMESTAMP)
BEGIN
	if year(ctime) = '2012' then
		insert into news_2012(uuid,title,body,ctime) values(uuid,title, body, ctime);
	end if;
	if year(ctime) = '2013' then
		insert into news_2013(uuid,title,body,ctime) values(uuid,title, body, ctime);
	end if;
	insert into news_index values(uuid, year(ctime));
END//
DELIMITER ;
		
		</pre>
		<p>插入触发器，负责获取 uuid 然后调用存储过程</p>
		<pre class="programlisting">
		
SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='';
DELIMITER //
CREATE TRIGGER `news_before_insert` BEFORE INSERT ON `news` FOR EACH ROW BEGIN
	IF new.uuid is null or new.uuid = '' or length(new.uuid) != 36 THEN
		set new.uuid=uuid();
	END IF;
	call news_insert(new.uuid,new.title,new.body,new.ctime);
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;
		
		</pre>
		<p>这个触发器用户保护表中的 uuid 值不被修改。</p>
		<pre class="programlisting">
		
SET @OLDTMP_SQL_MODE=@@SQL_MODE, SQL_MODE='';
DELIMITER //
CREATE TRIGGER `news_before_update` BEFORE UPDATE ON `news_2013` FOR EACH ROW BEGIN
	set new.uuid = old.uuid;
END//
DELIMITER ;
SET SQL_MODE=@OLDTMP_SQL_MODE;
		
		</pre>
	</div>
</div>
	
<div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="db.bigdata"></a>3.1.26. MySQL 大数据操作注意事项</h3></div><div><h4 class="subtitle">http://netkiller.github.io/journal/mysql.parallel.html</h4></div></div></div>
	
	
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874250000"></a>3.1.26.1. 关于 delete</h4></div></div></div>
		
		<p>delete from mytable 必死无疑，你需要分批删除，尽量缩小每个批次删除的记录数，delete 是可以并行执行的，你可以同时运行多个删除操作</p>
		<pre class="screen">
		
mysql&gt; show processlist;
+--------+-----------------+---------------------+-----------+---------+-------+-----------------------------+--------------------------------------------------------+
| Id     | User            | Host                | db        | Command | Time  | State                       | Info                                                   |
+--------+-----------------+---------------------+-----------+---------+-------+-----------------------------+--------------------------------------------------------+
|      1 | event_scheduler | localhost           | NULL      | Daemon  |    52 | Waiting for next activation | NULL                                                   |
| 115986 | dba             | localhost           | example   | Query   |     0 | NULL                        | show processlist                                       |
| 117446 | dba             | localhost           | example   | Query   |    20 | updating                    | delete from mytable where OPEN_TIME like '2011.11.28%' |
| 117525 | dba             | localhost           | example   | Query   |     2 | updating                    | delete from mytable where OPEN_TIME like '2011.12.02%' |
| 117526 | dba             | localhost           | example   | Query   |    49 | updating                    | delete from mytable where OPEN_TIME like '2011.12.12%' |
| 117527 | dba             | localhost           | example   | Query   |     6 | updating                    | delete from mytable where OPEN_TIME like '2011.12.21%' |
| 117528 | dba             | localhost           | example   | Query   |    64 | updating                    | delete from mytable where OPEN_TIME like '2011.12.30%' |
| 117546 | dba             | localhost           | example   | Query   |    33 | updating                    | delete from mytable where OPEN_TIME like '2011.11.10%' |
+--------+-----------------+---------------------+-----------+---------+-------+-----------------------------+--------------------------------------------------------+
23 rows in set (0.00 sec)
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874248192"></a>3.1.26.2. 关于 update</h4></div></div></div>
		
		<p>在电商领域常常遇到一个问题“调价”，经常需要调整一批商品的价格, 程序猿一条语句搞定有没有？</p>
		<pre class="screen">
		
update goods set price=price+10 where category_id = xxx
		
		</pre>
		<p>在开发，测试环境是可以通过测试的，一旦部署到生产环境，必死无疑</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874245888"></a>3.1.26.3. 关于创建索引</h4></div></div></div>
		
		<p>大表创建索引需要很久的时间，通常要经历 manage keys 与 copy to tmp table 的过程</p>
		<pre class="screen">
		
mysql&gt; show processlist;
+--------+-----------------+---------------------+----------+---------+-------+-----------------------------+------------------------------------------------------------------+
| Id     | User            | Host                | db       | Command | Time  | State                       | Info                                                             |
+--------+-----------------+---------------------+----------+---------+-------+-----------------------------+------------------------------------------------------------------+
|      1 | event_scheduler | localhost           | NULL     | Daemon  |    47 | Waiting for next activation | NULL                                                             |
| 115986 | dba             | localhost           | example  | Query   |     0 | NULL                        | show processlist                                                 |
| 118814 | dba             | 192.168.6.20:50459  | example  | Query   |     8 | copy to tmp table           | ALTER TABLE `mytable` ADD INDEX `modifiy_time` (`MODIFY_TIME`)   |
+--------+-----------------+---------------------+----------+---------+-------+-----------------------------+------------------------------------------------------------------+
17 rows in set (0.00 sec)
		
		</pre>
		<p>删除索引，也需要经理 copy to tmp table 过程，漫长的等待</p>
		<pre class="screen">
		
mysql&gt; show processlist;
+--------+-----------------+---------------------+--------------+---------+-------+-----------------------------+-------------------------------------------------+
| Id     | User            | Host                | db           | Command | Time  | State                       | Info                                            |
+--------+-----------------+---------------------+--------------+---------+-------+-----------------------------+-------------------------------------------------+
|      1 | event_scheduler | localhost           | NULL         | Daemon  |    11 | Waiting for next activation | NULL                                            |
| 115986 | dba             | localhost           | example      | Query   |     0 | NULL                        | show processlist                                |
| 118814 | dba             | 192.168.6.20:50459  | example      | Query   |     4 | copy to tmp table           | ALTER TABLE `mytable`	DROP INDEX `modifiy_time` |
+--------+-----------------+---------------------+--------------+---------+-------+-----------------------------+-------------------------------------------------+
17 rows in set (0.00 sec)
		
		</pre>
		<p>所以数据设计要深思熟虑，做到提前未雨绸缪，不要亡羊补牢</p>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874242800"></a>3.1.26.4. 关于 OPTIMIZE</h4></div></div></div>
		
		<p>OPTIMIZE 的操作是将当前表复制到临时表操作后再删除当前表，最后将临时表改名</p>
		<pre class="screen">
		
mysql&gt; show processlist;
+--------+-----------------+---------------------+---------------------------+---------+-------+-----------------------------+--------------------------+
| Id     | User            | Host                | db                        | Command | Time  | State                       | Info                     |
+--------+-----------------+---------------------+---------------------------+---------+-------+-----------------------------+--------------------------+
|      1 | event_scheduler | localhost           | NULL                      | Daemon  |    14 | Waiting for next activation | NULL                     |
| 115835 | dba             | 192.168.6.20:49664  | example                   | Query   |     9 | copy to tmp table           | OPTIMIZE TABLE `mytable` |
| 115986 | dba             | localhost           | example                   | Query   |     0 | NULL                        | show processlist         |
+--------+-----------------+---------------------+---------------------------+---------+-------+-----------------------------+--------------------------+
17 rows in set (0.00 sec)
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874240976"></a>3.1.26.5. 关于切换引擎</h4></div></div></div>
		
		<p>转换ENGINE从MyISAM到InnoDB会经历creating table然后copy to tmp table在修改表名几个阶段，过程非常缓慢</p>
		<pre class="screen">
		
mysql&gt; show processlist;
+------+-----------------+---------------------+---------+---------+-------+-----------------------------+------------------------------------------+
| Id   | User            | Host                | db      | Command | Time  | State                       | Info                                     |
+------+-----------------+---------------------+---------+---------+-------+-----------------------------+------------------------------------------+
|    1 | event_scheduler | localhost           | NULL    | Daemon  |    10 | Waiting for next activation | NULL                                     |
| 3167 | dba             | 192.168.6.20:56723  | example | Query   |     2 | creating table              | ALTER TABLE `mytable`	ENGINE=InnoDB   |
| 3172 | dba             | localhost           | example | Query   |     0 | NULL                        | show processlist                         |
+------+-----------------+---------------------+---------+---------+-------+-----------------------------+------------------------------------------+
18 rows in set (0.00 sec)
		
		</pre>
		<p>copy to tmp table 过程</p>
		<pre class="screen">
		
mysql&gt; show processlist;
+------+-----------------+---------------------+---------+---------+-------+-----------------------------+------------------------------------------+
| Id   | User            | Host                | db      | Command | Time  | State                       | Info                                     |
+------+-----------------+---------------------+---------+---------+-------+-----------------------------+------------------------------------------+
|    1 | event_scheduler | localhost           | NULL    | Daemon  |    21 | Waiting for next activation | NULL                                     |
| 3167 | dba             | 192.168.6.20:56723  | example | Query   |    13 | copy to tmp table           | ALTER TABLE `mytable`	ENGINE=InnoDB   |
| 3172 | dba             | localhost           | example | Query   |     0 | NULL                        | show processlist                         |
+------+-----------------+---------------------+---------+---------+-------+-----------------------------+------------------------------------------+
18 rows in set (0.00 sec)
		
		</pre>
		<p>此时我们查看mysql data目录会看到临时表文件</p>
		<pre class="screen">
		
# ll /var/lib/mysql/hx9999_real_history/
		
-rw-rw---- 1 mysql mysql      9522 May 16 17:17 #sql-c2f_c5f.frm
-rw-rw---- 1 mysql mysql        48 May 16 17:17 #sql-c2f_c5f.par
-rw-rw---- 1 mysql mysql 637534208 May 16 17:29 #sql-c2f_c5f#P#p0.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p1.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p2.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p3.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p4.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p5.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p6.ibd
-rw-rw---- 1 mysql mysql    180224 May 16 17:17 #sql-c2f_c5f#P#p7.ibd		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874236768"></a>3.1.26.6. 确保SELECT不被受阻</h4></div></div></div>
		
		<p>使用各种手段保证select操作不被受阻，只要select一直可以查询网站前端就能提供80%的功能，一旦select受阻一切都是浮云。</p>
		<p>保证 select 操作优先于其他操作</p>
		<pre class="screen">
		
UPDATE [LOW_PRIORITY] [IGNORE] tbl_name  
SET col_name1=expr1 [, col_name2=expr2 ...]  
[WHERE where_definition]  
[ORDER BY ...]  
[LIMIT row_count]		
		
		</pre>
		<p>update的时候增加 LOW_PRIORITY 参数，可以降低更新语句的优先级。</p>
		<p>my.cnf</p>
		<pre class="screen">
		
[mysqld]		
low_priority_updates=1
		
		</pre>
		<p>或者启动是添加--low-priority-updates参数</p>
		<p>全局开启</p>
		<pre class="screen">
		
SET @@global.low_priority_updates = 1;		
		
		</pre>
		<p>适用于本次会话连接</p>
		<pre class="screen">
		
SET @@session.low_priority_updates = 1;
		
		</pre>
		<p>使用 limit 限制更新记录的数量</p>
		<pre class="screen">
		
update mytable set status='Y' where status='N' limit 1000;		
		
		</pre>
	</div>
	<div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="idm452874236512"></a>3.1.26.7. 记录操作者</h4></div></div></div>
		
		<pre class="screen">
		
update mytable set status='Y',update_date=now(),op_user='neo' where status='N';
		
		</pre>
	</div>
</div>
</div>

	

	


	

	


</div><div xmlns="" id="SOHUCS"></div><script xmlns="" charset="utf-8" type="text/javascript" src="https://cy-cdn.kuaizhan.com/upload/changyan.js"></script><script xmlns="" type="text/javascript">
window.changyan.api.config({
appid: 'cyvwjQUG3',
conf: 'prod_ef966242df3d8b5acb1e0ee9fc01cafe'
});
</script><script xmlns="" type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?u=r5HG&amp;d=9mi5r_kkDC8uxG8HuY3p4-2qgeeVypAK9vMD-2P6BYM"></script><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="../多维度架构之压力测试.html">上一页</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="security.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">2.19. 多维度架构之压力测试 </td><td width="20%" align="center"><a accesskey="h" href="../index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 4 章 数据库安全</td></tr></table></div><script xmlns="">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-11694057-1', 'auto');
  ga('send', 'pageview');

</script><script xmlns="" async="async">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?93967759a51cda79e49bf4e34d0b0f2c";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script xmlns="" async="async">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script></body></html>